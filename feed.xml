<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://riscuinho.github.io/</id><title>RISCuinho</title><subtitle>**RISC**uinho - A scratch in the possibilities in the universe of microcontrollers </subtitle> <updated>2021-12-17T19:36:26-03:00</updated> <author> <name>Carlos Delfino</name> <uri>https://riscuinho.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://riscuinho.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="pt-BR" href="https://riscuinho.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2021 Carlos Delfino </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>ABI - Integer, Long, Pointer (ILP)</title><link href="https://riscuinho.github.io/posts/ABI_Inteiros_Longos_Pointers/" rel="alternate" type="text/html" title="ABI - Integer, Long, Pointer (ILP)" /><published>2021-08-11T18:40:00-03:00</published> <updated>2021-08-11T18:40:00-03:00</updated> <id>https://riscuinho.github.io/posts/ABI_Inteiros_Longos_Pointers/</id> <content src="https://riscuinho.github.io/posts/ABI_Inteiros_Longos_Pointers/" /> <author> <name>Carlos Delfino</name> </author> <category term="abi" /> <summary> ILP é um termo que se refere a como o compilador trata os números Inteiros, Longos e os Ponteiros, qual seu comprimento e como são armazenados e manipulados internamente quando manipulados pelo Assembly, são arquiteturas ABI (Application Binary Interface), veremos aqui também que pontos flutuantes também são tratados neste ABI quando a são pós-sufixados com f ou d. Conforme o Guia Prático RISC... </summary> </entry> <entry><title>Atributos de Propriedades</title><link href="https://riscuinho.github.io/posts/atributos/" rel="alternate" type="text/html" title="Atributos de Propriedades" /><published>2021-08-08T18:40:00-03:00</published> <updated>2021-08-08T18:40:00-03:00</updated> <id>https://riscuinho.github.io/posts/atributos/</id> <content src="https://riscuinho.github.io/posts/atributos/" /> <author> <name>Carlos Delfino</name> </author> <category term="hdl" /> <summary> Os atributos foram adicionados no Verilog 2001 para definir propriedades especiais de algum objeto ou declaração para uso em simuladores e sintetizadores. Porém o Verilog 2001 não especifica quais atributos devem ser declarados, isso é definido pela ferramenta ou outros padrões. Podem ser usados como prefixo de alguma declaração, itens do módulo, conexões de porta. E como sufixo para um operad... </summary> </entry> <entry><title>Programming Language Interface (PLI)</title><link href="https://riscuinho.github.io/posts/Programming_Language_interface/" rel="alternate" type="text/html" title="Programming Language Interface (PLI)" /><published>2021-07-08T08:40:00-03:00</published> <updated>2021-07-08T08:40:00-03:00</updated> <id>https://riscuinho.github.io/posts/Programming_Language_interface/</id> <content src="https://riscuinho.github.io/posts/Programming_Language_interface/" /> <author> <name>Carlos Delfino</name> </author> <category term="programacao" /> <category term="verilog" /> <summary> programming Lanaguage Interface (PLI) é um mecanismo qe fornece uma interface de programa com a aplicação (Application Program Interface - API) para o Verilog. Em essência ele é um mecanismo para invocar funções escritas em linguagem C a partir do código escrito em Verilog. A construção que invoca a rotina PLI no código Verilog é normalmente chamado de uma “system call” (Chamada de Sistema), se... </summary> </entry> <entry><title>Diferenças entre BigEndian, Little Endian e Bit Endianness</title><link href="https://riscuinho.github.io/posts/Diferencas_entre_BigEndian_Little_Endian_e_Bit_Endianness/" rel="alternate" type="text/html" title="Diferenças entre BigEndian, Little Endian e Bit Endianness" /><published>2021-07-07T18:40:00-03:00</published> <updated>2021-07-07T23:11:08-03:00</updated> <id>https://riscuinho.github.io/posts/Diferencas_entre_BigEndian_Little_Endian_e_Bit_Endianness/</id> <content src="https://riscuinho.github.io/posts/Diferencas_entre_BigEndian_Little_Endian_e_Bit_Endianness/" /> <author> <name>Carlos Delfino</name> </author> <category term="programacao" /> <category term="cplusplus" /> <summary> Para o iniciante este conceito pode parecer bastante confuso, e até inútil, mas para quem deseja trabalhar com microcontroladores, processadores e principalmente redes a nível de protocolos é fundamental seu entendimento. Big Endian ou Little Endian, qual o impacto na transmissão de dados de um sistema para outro, entre o módulo e o microcontrolador? Artigo originalmente publicado no site de... </summary> </entry> <entry><title>“Zicsr”, Control and Status Register (CSR) Instructions, Version 2.0</title><link href="https://riscuinho.github.io/posts/ziscr_-_control_and_status_register/" rel="alternate" type="text/html" title="“Zicsr”, Control and Status Register (CSR) Instructions, Version 2.0" /><published>2021-07-03T18:14:00-03:00</published> <updated>2021-07-03T18:14:00-03:00</updated> <id>https://riscuinho.github.io/posts/ziscr_-_control_and_status_register/</id> <content src="https://riscuinho.github.io/posts/ziscr_-_control_and_status_register/" /> <author> <name>Carlos Delfino</name> </author> <category term="extensoes" /> <category term="rv32i" /> <category term="zicsr" /> <summary> O RISC-V define um endereço separado de 4096 registradores de Status e Controle, associados com cada hart. CSRs são primáriamente utilizads pela arquitetura privilegiada, há vários usos no código não privilegiado incluindo para contadores e timers, e para status de ponto-flutuante. Os contadores e timers não são considerados obrigatórios no ISA base, e para instruções CSR necessárias para ace... </summary> </entry> </feed>

[ { "title": "ABI - Integer, Long, Pointer (ILP)", "url": "/posts/ABI_Inteiros_Longos_Pointers/", "categories": "abi", "tags": "abi, ilp, ilp32, ilp32f, ilp32d, ilp64, ilp64f, ilp64d, application binary interface, integer, long, pointer, float, float point, soft float point, hard float point", "date": "2021-08-11 18:40:00 -0300", "snippet": "ILP √© um termo que se refere a como o compilador trata os n√∫meros Inteiros, Longos e os Ponteiros, qual seu comprimento e como s√£o armazenados e manipulados internamente quando manipulados pelo Assembly, s√£o arquiteturas ABI (Application Binary Interface), veremos aqui tamb√©m que pontos flutuantes tamb√©m s√£o tratados neste ABI quando a s√£o p√≥s-sufixados com f ou d.Conforme o Guia Pr√°tico RISC-V, p√°gina 44 (69), ‚ÄúOs compiladores RISC-V suportam v√°rias ABIs, dependendo se as extens√µes F e D est√£o presentes. Para o RV32, as ABIs s√£o denominadas ilp32, ilp32f e ilp32d. ilp32 significa que os tipos de dados de linguagem C int, long e pointer s√£o todos de 32 bits; o sufixo opcional indica como os argumentos de ponto flutuante s√£o passados. No ilp32, argumentos de ponto flutuante s√£o passados em registradores de inteiros. No ilp32f, argumentos de ponto flutuante de precis√£o simples s√£o passados em registradores de ponto flutuante. No ilp32d, argumentos de ponto flutuante de precis√£o dupla tamb√©m s√£o passados em registradores de ponto flutuante.Naturalmente, para passar um argumento de ponto flutuante em um registrador de ponto flutuante, √© necess√°rio a extens√£o de ponto flutuante F ou D da ISA (consulte o Cap√≠tulo 5). Para compilar o c√≥digo para o RV32I (GCC flag ‚Äò-march=rv32i‚Äô), voc√™ deve usar o ABI ilp32 (GCC flag ‚Äò-mabi=ilp32‚Äô). Por outro lado, ter instru√ß√µes de ponto flutuante n√£o significa que a conven√ß√£o de chamada deva utiliz√°-las; Assim, por exemplo, o RV32IFD √© compat√≠vel com todas as tr√™s ABIs: ilp32, ilp32f e ilp32d.O linker verifica se a ABI do programa corresponde a todas as suas bibliotecas. Embora o compilador tenha suporte muitas combina√ß√µes de extens√µes ISA e ABIs, apenas alguns conjuntos de bibliotecas podem ser instalados. Assim, um erro comum √© vincular um programa sem ter as bibliotecas compat√≠veis instaladas. O linker n√£o produzir√° uma mensagem de diagn√≥stico √∫til nesse caso; ele tentar√° simplesmente vincular-se a uma biblioteca incompat√≠vel e, em seguida, informar√° a incompatibilidade. Esse erro geralmente ocorre apenas quando compila-se em um computador para um computador diferente (cross compiling).‚Äù" }, { "title": "Atributos de Propriedades", "url": "/posts/atributos/", "categories": "hdl", "tags": "hdl, atributos, verilog, propriedades", "date": "2021-08-08 18:40:00 -0300", "snippet": "Os atributos foram adicionados no Verilog 2001 para definir propriedades especiais de algum objeto ou declara√ß√£o para uso em simuladores e sintetizadores. Por√©m o Verilog 2001 n√£o especifica quais atributos devem ser declarados, isso √© definido pela ferramenta ou outros padr√µes.Podem ser usados como prefixo de alguma declara√ß√£o, itens do m√≥dulo, conex√µes de porta. E como sufixo para um operador ou chamada a fun√ß√£o.Atributos que n√£o tem valor designado tem o valor ‚Äú1‚Äù como padr√£o. Multiplos atributos s√£o declarados como uma lista separa por v√≠rgula.ExemplosPrefixado em uma declara√ß√£o case.(* full_case, parallel_case *) case (state)endcaseSufixo para um operador.assign sum = a + (* CLA=1 *) b;iVerilogO iVerilog possui alguns atributos que s√£o √∫teis para simula√ß√£o e sintese, abaixo segue o original da listagem obtido no fonte do GitHub.ATTRIBUTE NAMING CONVENTIONSAttributes that are specific to Icarus Verilog, and are intended to beof use to programmers, start with the prefix ‚Äúivl_‚Äù.Attributes with the ‚Äúivl‚Äù prefix are set aside for internaluse. They may be generated internally by the compiler. They need notbe documented here.ATTRIBUTES TO CONTROL SYNTHESISThe following is a summary of Verilog attributes that Icarus Verilogunderstands within Verilog source files to control synthesisbehavior. This section documents generic synthesis attributes. Fortarget specific attributes, see target specific documentation.These attributes only effect the behavior of the synthesizer. Forexample, the ivl_combinational will not generate an error messageif the Verilog is being compiled for simulation. (It may generate awarning.)Attributes for ‚Äúalways‚Äù and ‚Äúinitial‚Äù statements(* ivl_combinational *)This attribute tells the compiler that the statement modelscombinational logic. If the compiler finds that it cannot makecombinational logic out of a marked always statement, it willreport an error.This attribute can be used to prevent accidentally inferringlatches or flip-flops where the user intended combinationallogic.(* ivl_synthesis_on *)This attribute tells the compiler that the marked always statementis synthesizable. The compiler will attempt to synthesize thecode in the marked &quot;always&quot; statement. If it cannot in any waysynthesize it, then it will report an error.(* ivl_synthesis_off *)If this value is attached to an &quot;always&quot; statement, then thecompiler will *not* synthesize the &quot;always&quot; statement. This can beused, for example, to mark embedded test bench code.Attributes for modules(* ivl_synthesis_cell *)If this value is attached to a module during synthesis, thatmodule will be considered a target architecture primitive, andits interior will not be synthesized further. The module cantherefore hold a model for simulation purposes.Attributes for signals (wire/reg/integer/tri/etc.)(* PAD = ‚Äú&quot; *)If this attribute is attached to a signal that happens to be aroot module port, then targets that support it will use the stringvalue as a list of pin assignments for the port/signal. The formatis a comma separated list of location tokens, with the format ofthe token itself defined by the back-end tools in use.Other Attributes[ none defined yet ]MISC(* _ivl_schedule_push *)If this attribute is attached to a thread object (always orinitial statement) then the vvp code generator will generate codethat causes the scheduler to push this thread at compile time. Thecompiler may internally add this attribute to always statements ifit detects that it is combinational. This helps resolve time-0races." }, { "title": "Programming Language Interface (PLI)", "url": "/posts/Programming_Language_interface/", "categories": "programacao, verilog", "tags": "pli, verilog, programacao", "date": "2021-07-08 08:40:00 -0300", "snippet": "programming Lanaguage Interface (PLI) √© um mecanismo qe fornece uma interface de programa com a aplica√ß√£o (Application Program Interface - API) para o Verilog. Em ess√™ncia ele √© um mecanismo para invocar fun√ß√µes escritas em linguagem C a partir do c√≥digo escrito em Verilog. A constru√ß√£o que invoca a rotina PLI no c√≥digo Verilog √© normalmente chamado de uma ‚Äúsystem call‚Äù (Chamada de Sistema), se for definida internamente no simulador, e ‚Äúuser-defined task‚Äù ou ‚Äúfunction‚Äù, se ela √© escrita pelo usu√°rio.Tanto para o System Call quanto para User-defined task o mecanismo b√°sico de funcionamento permanece o mesmo para o PLI, ortanto sempre usarei o termo System Call para fazer refer·∫Ωncia a tal recurso de chamda.Chamadas como $display, $monitor, $finish s√£o System Calls internas de qualquer simulador. Podemos vir a encontrar outras especificas o que √© raro.O PLI √© usado para fazer tarefas que normalmente o Verilog n√£o faria, como caregar um arquivo para um registrador, ou gravar noutro arquivo a situa√ß√£o de sinais especificos para depura√ß√£o. Podemos tamb√©m descrever modelos funcionais, calcular atrasos e obter informa√ß√µes de designer como a hierarquia de inst√£ncia√ß√£o dos dos m√≥dulos." }, { "title": "Diferen√ßas entre BigEndian, Little Endian e Bit Endianness", "url": "/posts/Diferencas_entre_BigEndian_Little_Endian_e_Bit_Endianness/", "categories": "programacao, cplusplus", "tags": "big endian, little endian, endianness, bit endianness, lsb, msb, bin√°rio, byte, bit, numera√ß√£o, endere√ßamento, manipula√ß√£o de bits, manipula√ß√£o e bytes, little end in, big end in", "date": "2021-07-07 18:40:00 -0300", "snippet": "Para o iniciante este conceito pode parecer bastante confuso, e at√© in√∫til, mas para quem deseja trabalhar com microcontroladores, processadores e principalmente redes a n√≠vel de protocolos √© fundamental seu entendimento. Big Endian ou Little Endian, qual o impacto na transmiss√£o de dados de um sistema para outro, entre o m√≥dulo e o microcontrolador?Artigo originalmente publicado no site de Carlos Delfino.O conceito de Big Endian e Little Endian, nomeado simplesmente de Endianess vem da transi√ß√£o dos computadores de m√©dio porte para os microcomputadores, quando estes passaram a endere√ßar tantos os bits quantos os Bytes de forma diferente. Mas tal problema √© principalmente observado quando lidamos com os Bytes, j√° que pode acarretar o embaralhamento at√© de texto causando confus√£o, mas no caso de tratamento num√©rica pode se tornar a fal√™ncia total do sistema.O problema se deu inicio, como j√° foi dito quando os microcomputadores surgiram, j√° que estes optaram em trabalhar com o conceito de Little Endian, mas o que √© este Endian? porque Big ou Little? bem Endian √© um termo cunhado em uma hist√≥ria que faz alus√£o as disputas politicas e religiosas na Europa, e descrita em uma hist√≥ria de fic√ß√£o escrita por Jonathan Swift em uma s√°tira escrita em 1726, Conhecida em portugu√™s como as Viagens de Gulliver, conta a hist√≥ria, que dois grupos de cidad√£os entram em guerra por n√£o concordarem qual o lado certo se deve quebrar o ovo, do lado maior (Big End) ou do lado menor (Little End), com isso uma guerra civil se instala separando os grupos.Na inform√°tica isso n√£o foi muito diferente, n√£o chegamos a uma guerra civil por isso, mas tivemos os sistemas separados em ‚ÄúBig End in‚Äù e ‚ÄúLittle End in‚Äù que define como os bits s√£o transmitidos em algum sistemas, e em outros, apenas quando lidamos com palavras (World/2 bytes, DWorld/4 bytes), seja o microprocessador 8 bits ou maiores.Nos tempos atuais, n√£o temos muitos problemas relativos a tal modo de endere√ßamento, porque quase todos os microprocessadores usam o Little Endian para endere√ßar seus dados, com exce√ß√£o de alguns como o antigo PowerMAC que usava um PowerPC especial travado para BIG Endian. Os outros computadores que n√£o usam este travamento permitem o chaveamento entre os dois modos no que tange a manipula√ß√£o dos bytes.Outras arquiteturas que trabalham com Big Endian s√£o, Motorola 68000 series (incluindo Freescale ColdFire), Xilinx Microblaze, SuperH, IBM z/Architecture, Atmel AVR32 e o Intel 8051 com aten√ß√£o para instru√ß√£o LCALL que endere√ßa usando Little Endian.Mas ent√£o, o que √© realmente Big Endian e Little Endian?Como j√° dito, nada mais √© do que a forma que os bytes e bits s√£o endere√ßados na mem√≥ria, quando se trata de bytes o Big Endian endere√ßa em uma palavra por exemplo do tipo 2 bytes, o primeiro byte como sendo o endere√ßo menor, e a segunda palavra o endere√ßo seguinte (+1 byte). Ja no Little Endian, o segundo Byte √© endere√ßado primeiro, isso para quem est√° come√ßando pode causar um certo desconforto, apesar que as linguagens abstraem para n√≥s tal problema, mesmo no C, isso n√£o √© percebido, mas podemos vir a ter problemas quando lidamos com ponteiros e at√© mesmo estruturas de dados (struct), j√° que o primeiro endere√ßo em um sistema Big Endian, n√£o ser√° a menor parte do n√∫mero, ou seja a parte menos significante (LSB), mas sim a parte mais significante (MSB).Vejamos abaixo para entendermos primeiro o conceito de LSB e MSB, que trata a import√¢ncia do bit ou byte na composi√ß√£o num√©rica.LSB representa a parte menos significativa do n√∫mero ou seja a parte mais a direita. Least Significant bit/Byte.J√° o MSB representa a parte mais significativa, ou seja a parte mais a esquerda do n√∫mero. Most Significant bit/Byte.Agora podemos entender melhor o conceito Little Endian e Big Endian, vejamos primeiro a n√≠vel de bits do que se trata.Para o Little Endian a representa√ß√£o num√©rica em bits, onde o algoritmo de convers√£o num√©rico que a maioria de n√≥s est√° acostumado pode ser facilmente representado na f√≥rmula:\\[\\sum_{i=0}^{N-1} b_i \\cdot 2^i\\]Temos ent√£o a seguinte ordena√ß√£o dos bits para a representa√ß√£o do n√∫mero 180 em Little Endian, onde o bit menos significativo √© tratado como sendo o bit 0 e o bit 7 √© o bit mais significativo.Representa√ß√£o gr√°fica do Little EndianPara o Big Endian os bits mantem sua disposi√ß√£o, por√©m sua ordem de transmiss√£o inverte, ou seja s√£o endere√ßados do MSB como sendo o primeiro bit, e o LSB como sendo o √∫ltimo bit, portanto a f√≥rmula de convers√£o passa a ser:\\[\\sum_{i=0}^{N-1} b_i \\cdot 2^{(N - 1 - i)}\\]Representa√ß√£o gr√°fica do Big EndianO Conceito EndianessEm se tratando de bits, o conceito Endianess afeta mais o hardware no que tange o endere√ßamento de mem√≥ria, transfer√™ncia de dados em barramentos, principalmente nos seriais, e opera√ß√µes de manipula√ß√£o de bits. J√° que, principalmente se formos usarmos m√°scaras do tipo bitwise √© preciso saber exatamente a ordem dos bits para n√£o haver enganos fatais.Vejamos agora como √© tratado o conceito endianess quando se trata de bytes, o que afeta mais a manipula√ß√£o do dado na mem√≥ria, quando √© representado com mais de dois bytes, por exemplo n√∫meros inteiros e short int em maquinas 32 bits.As imagem abaixo representam dois n√∫meros inteiros armazenado na mem√≥ria de um microcontrolador qualquer que seja do tipo Little Endian, a primeira representa um n√∫mero de 16bits ou seja um Word, o segundo um n√∫mero de 32 bits, Double Word (DWord).Representa√ß√£o gr√°fica do Big Endian para um WordRepresenta√ß√£o gr√°fica do Big Endian para um DWordComo pode ver o byte mais significativo √© armazenado no endere√ßo mais baixo da mem√≥ria, sendo ent√£o acessado primeiramente, e o byte menos significativo √© armazenando posteriormente. Na representa√ß√£o o endere√ßo de mem√≥ria come√ßa a contar em a.Vejamos agora como o mesmo n√∫mero fica representado em um sistema Little Endian. Temos a seguir os mesmos n√∫meros usados na representa√ß√£o anterior, por√©m agora utilizado o mecanismo Little Endian para armazen√°-lo.Representa√ß√£o gr√°fica do Little Endian para um WordRepresenta√ß√£o gr√°fica do Little Endian para um DWordHouve √©pocas que tal conflito quando transferindo dados entre computadores que usavam sistemas diferentes (chamdos bytesex), ou seja transmitindo de um sistema Little Endian para um sistema Big Endian a string UNIX, foi identificado como NUXI Problem, ou seja o ‚Äúproblema NUXI‚Äù, devido a invers√£o da String ‚ÄúUNIX‚Äù.Como pode ver a cada par de bytes, haveria uma invers√£o, de dos dois bytes, causando um certo transtorno.Um exemplo do formato Little Endian em CAbaixo est√£o dois c√≥digos que demonstra como um n√∫mero inteiro √© armazenado na m√©moria, o primeiro um n√∫mero de 16 bits, um t√≠pico inteiro, o outro um n√∫mero de de 32 bits, ou seja um t√≠pico inteiro longo.Neste exemplo mostramos como um inteiro de 2 bytes (16bits) √© armazenado na mem√≥ria em um formato Little Endian:#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;struct DWORD { uint8_t a0; uint8_t a1; } ;int main(void){ struct DWORD dw; dw.a0 = 0xDF; dw.a1 = 0xEA; printf(&quot;Endere√ßo 0: %#X\\nEndere√ßo 1: %#X\\n: %#X\\n&quot;, dw.a0, dw.a1); uint32_t dw1; memcpy(&amp;amp;dw1, &amp;amp;dw,4); //dw1 = 2; printf(&quot; Endere√ßos 1 0\\n&quot;); printf(&quot;-------------------\\n&quot;); printf(&quot;Valor Word: %#hX\\n&quot;, dw1); return 0;Resultado para um WordA seguir um outro exemplo para um inteiro longo de 4 bytes (32 bits), apresentando como √© armazenado na mem√≥ria em um formato Little Endian. Observe as pequenas diferen√ßas no c√≥digo:#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;struct DWORD { uint8_t a0; uint8_t a1; uint8_t a2; uint8_t a3; } ;int main(void){ struct DWORD dw; dw.a0 = 0xDF; dw.a1 = 0xEA; dw.a2 = 0xAB; dw.a3 = 0xCF; printf(&quot;Endere√ßo 0: %#X\\nEndere√ßo 1: %#X\\nEndere√ßo 2: %#X\\nEndere√ßo 3: %#X\\n&quot;, dw.a0, dw.a1, dw.a2, dw.a3); uint32_t dw1; memcpy(&amp;amp;dw1, &amp;amp;dw,4); printf(&quot; Endere√ßos 3 2 1 0\\n&quot;); printf(&quot;-------------------\\n&quot;); printf(&quot;Valor DWord: %#lX\\n&quot;, dw1); return 0;}Resultado para um DWordOutras formas de representa√ß√£oH√° outras formas de representa√ß√£o Endianess formas que misturam convenientemente os dois formatos acima, por√©m n√£o entraremos em detalhes aqui como s√£o apresentadas e utilizadas.Fontes https://en.wikipedia.org/wiki/Endianness https://en.wikipedia.org/wiki/Bit_numbering https://support.microsoft.com/pt-br/kb/102025 http://infocenter.arm.com/help/topic/com.arm.doc.dui0552a/I1835.html http://david.carybros.com/html/endian_faq.html https://www.ietf.org/rfc/ien/ien137.txt" }, { "title": "‚ÄúZicsr‚Äù, Control and Status Register (CSR) Instructions, Version 2.0", "url": "/posts/ziscr_-_control_and_status_register/", "categories": "extensoes, rv32i, zicsr", "tags": "rv32i, rv64i, rv128i, extensoes, 32bits, instrucoes, isa, zicsr, csr, control and status register, hart, timers, contadores, clock", "date": "2021-07-03 18:14:00 -0300", "snippet": "O RISC-V define um endere√ßo separado de 4096 registradores de Status e Controle, associados com cada hart.CSRs s√£o prim√°riamente utilizads pela arquitetura privilegiada, h√° v√°rios usos no c√≥digo n√£o privilegiado incluindo para contadores e timers, e para status de ponto-flutuante.Os contadores e timers n√£o s√£o considerados obrigat√≥rios no ISA base, e para instru√ß√µes CSR necess√°rias para acessa-las est√£o tratadas separadamente na especifica√ß√£o no cap√≠tulo 2. Sendo assim, tamb√©m tratarei as instru√ß√µes especificas separamente." }, { "title": "Desenvolvendo um Sistema Operaconal para o RISCuinho passo a Passo", "url": "/posts/os_step-by-step/", "categories": "step-by-step", "tags": "step-by-step, os, operate system, bsd, linux, development, rv32m", "date": "2021-07-03 14:40:00 -0300", "snippet": "Neste artigo vou anotar meus estudos de como desenvolver um Sistema Operacional para o RISCuinho, como no momento somente temos a extens√£o RV32I funcionando n√£o poderemos fazer quase nada, mas isso ser√° motiva√ß√£o para desenvolver outras extens√µes conforme ouver demanda de instru√ß√µes, assim irei desenvolver as demais extens√µes conforme a demanda deste sistema operacional.Este trabalho intercede e complementa outros trabalhos que tem a mesma caracteristicas, como o desenvolvimento da extens√£o RV32V que demanda as extens√µes RV32M, e o desenvolvimento do Chocopy que tamb√©m demanda a extens√£o RV32M.Extens√µes que precisam ser desenvolvidasAl√©m do b√°sico RV32I, h√° outras extens√µes que precisam ser desenvolvidas por completo ou parcialmente. Al√©m de recursos de hardware que podem trazer grandes avan√ßos quanto ao desempenho do RISCuinho, estas melhorias de hardware ainda n√£o est√£o no meu foco principal, pois preciso me aprofundar melhor, principalmente, no desenvolvimento do pipeline, portanto de imediato j√° identifico que preciso finalizar a extens√£o RV32M, tabm√©m √© prov√°vel que ser√° necess√°rio o desenvolvimento da extens√£o RV32A.Aos poucos, conforme estudo irei ampliando as anota√ß√µes desta se√ß√£o.O que preciso para come√ßar.Vamos come√ßar os estudos usando o QEMU, mas conforme o entendimento do desenvolvimento tomar corpo irei criar outro artigo usando o pr√≥prio RISCuinho simulado via iVerilog, ainda n√£o sei como irei fazer para lidar com quest√µes de comunica√ß√£o externa, mas at√© l√°, acredito que encontrarei solu√ß√µes, use os coment√°rios abaixo caso queira colaborar de alguma forma.Ferramentas para desenvolvimentoBem para desenvolver voc√™ vai precisar: GIT e ferramentas de apoio para baixar c√≥digos de exemplo dos reposit√≥rios de desenvolvedores build-essential, que possui o GCC e outras ferramentas como binutils para compila√ß√£o de c√≥digo libfdt-dev e libsdl2-dev VI, o melhor editor para se trabalhar no Linux, tamb√©m √© bom para o Windows, mas no Windows eu prefiro o NotePad++sudo apt install build-essential git gitk vim libfdt-dev libsdl2-dev" }, { "title": "RISCuinho EABI", "url": "/posts/riscuinho_eabi/", "categories": "EABI", "tags": "assembly, c, cplusplus, abi, eabi, gcc", "date": "2021-07-01 08:40:00 -0300", "snippet": "A proposta para RISCuinho Embedded ABI (EABI) √© um espelho da proposta RISC-V Embedded ABI (EABI) Version 20190525Ser√° traduziada aos poucos.EABIThis is a proposal for a new ABI for RISC-V embedded systems. The newABI will be called the embedded ABI, aka EABI, and is intended forembedded targets only. It will not be used for Linux, which willcontinue to use the existing Unix ABI (UABI).NOTE: The UABI might provide higher performance or lower code size forsome embedded applications, and will continue to be available forembedded use.Contributors (please suggest corrections): Krste Asanovic, PalmerDabbelt, Bruce Hoult, Liviu Ionescu, Andrew Waterman, Jim WilsonGoals. The EABI is designed to reduce interrupt latency by reducing thenumber of caller-saved registers.. The EABI calling convention is designed to work the same on allRISC-V embedded targets with the same XLEN (i.e., for 32-bit systems,RV32I, RV32E, with or without the Zfinx option).. The EABI is designed to reduce library code size by reducing thesize of the largest floating-point data type from 128 bits to 64 bits.EABI OverviewThe EABI is based on the existing Unix ABI with the followingchanges:. The number of argument registers is reduced from 8 to 4.. The upper 16 x registers (x16-x31), where present, are allcallee-saved. (In UABI, 2 are argument registers and 4 aretemporaries.). The number of temporary registers is reduced from 3 to 2.. The long double type size will be reduced from 128-bits to64-bits.NOTE: Reducing the number of argument registers means 4 fewerregisters need to be saved in an interrupt handler, which gives fasterinterrupt response time.NOTE: Making the upper 16 registers all callee-saved means that we canuse the same calling convention for RV32I and RV32E. Also, it means 4fewer registers need to be saved in an interrupt handler, on top ofthe reduction from above.NOTE: Reducing the number of temporary registers means one lessregister to save in an interrupt handler.NOTE: Optimizing EABI for interrupt latency with fewer caller-saveregisters might have negative effects on performance and/or code sizerelative to UABI.NOTE: Reducing the size of long double helps reduce code size whenprintf is linked in. Currently, for a soft-float target, we need tolink in the 32-bit float, 64-bit double, and 128-bit long doublesoft-float libraries. With the change, we only need to link in thefirst two libraries. Similarly, on a hard-float target, we reducefrom one soft-float library to zero linked in with a printf call.Register Usage and Symbolic NamesThe RISC-V base ISA assumes x1 and x5 are used as link registersto hint any return address predictors in the machine, while the RISC-VC compressed extension effectively mandates x1 is the return addressregister and that x2 is the stack pointer. ¬† EABI Name Description Saver x0 zero Hard-wired zero value - x1 ra Return address Caller x2 sp Stack pointer Callee x3 gp Global pointer - x4 tp Thread pointer - x5 t0 Temporary/link register Caller x6 s3 Saved register Callee x7 s4 Saved register Callee x8 s0/fp Saved register/frame pointer Callee x9 s1 Saved register Callee x10 a0 Argument/return value Caller x11 a1 Argument/return value Caller x12 a2 Argument Caller x13 a3 Argument Caller x14 s2 Saved register Callee x15 t1 Temporary Caller x16-x31 s5-s20 Saved registers Callee NOTE: If an entire embedded application and its libraries make no useof thread-local storage, the tp register becomes available as a globalregister or as a temporary register, at the application‚Äôs discretion.If the __global_pointer$ symbol is not defined, the gp registerbecomes available in the same fashion. Using the tp and gp registersin this alternate way is a nonstandard extension to the EABI and mightnot compose with some EABI libraries.EABI Stack AlignmentThe stack alignment for XLEN=32 systems is 8 bytes.NOTE: Stack alignment is not reduced below 8 bytes for RV32 systems incase of hardware support of double-precision floating-point (RV32D).The stack alignment for XLEN=64 systems is 16 bytes.NOTE: Maintaining stack alignment of 2*XLEN can help optimizedmicroarchitectures save/restore multiple registers per cycle.EABI Interrupt Handler Context SaveAn interrupt scheme wishing to provide a standard EABI interface forinterrupt handlers needs to save the following registers beforeentering an EABI interrupt handler: ¬† ¬† ra x1 t0 x5 a0 x10 a1 x11 a2 x12 a3 x13 t1 x15 In addition, sp (x2) will need to be adjusted and might need to beswitched to a different interrupt stack; gp (x3) might need to beswitched to a different small-data section; and tp (x4) might needto be switched to a different thread-local storage region.Floating-Point Registers and Argument PassingFloating-point arguments are always passed in the integer registersa0-a3 or on the stack.Where the separate f floating-point registers are present, they aretreated as all callee-save, so there is no increase in interruptlatency. Systems with separate f registers will have to movefloating-point arguments to the floating-point registers to usehardware floating-point instructions, after first creating astack frame and storing some callee-saved floating-point registers.NOTE: A separate hard-float EABI could add a few caller-savedfloating-point argument and temporary registers to improve performanceand code size, but at the expense of supporting another incompatibleABI with increased interrupt latency.Systems implementing Zfinx have no additional f registers andprovide hardware floating-point instructions operating directly on thex registers.GCC ChangesThe gcc inline expanded memcpy will be changed to copy 4 registersat a time instead of 12, since we have eliminated 9 temporaryregisters.The gcc REG_ALLOC_ORDER macro is ABI-dependent. This can be fixedby defining the ADJUST_REG_ALLOC_ORDER macro to point at a functionthat then modifies the register allocation order depending on the ABI.Refer·∫Ωncia https://github.com/riscv/riscv-eabi-spec/edit/master/EABI.adoc" }, { "title": "Riscuinho GCC", "url": "/posts/riscuinho-gcc/", "categories": "gcc", "tags": "gcc, binutils, as, gdb", "date": "2021-06-28 18:40:00 -0300", "snippet": "Gcc e Binutils para o RISCuinho foram compilados multi-lib para rv32i com ilp32; rv32im com ilp32 and rv32imc with ilp32 que reusar√° este conjunto multi-lib../configure ‚Äìprefix=/opt/riscuinho ‚Äìhost=i686-riscuinho-linux-gnu ‚Äìprogram-prefix=‚Äùriscuinho-‚Äú ‚Äìwith-multilib-generator=‚Äùrv32ic-ilp32‚Äìm*v‚Äù ‚Äìwith-pkgversion=‚ÄùRISCuinho-GCC‚Äù ‚Äìwith-bugurl=‚Äùhttps://riscuinho.github.io/gcc‚Äù ‚Äìwith-documentation-root-url=‚Äùhttps://riscuinho.github.io/gcc‚Äù ‚Äìwith-changes-root-url=‚Äùhttps://riscuinho.github.io/gcc‚Äù version: 11.1.0 multilib: . !march=rv32ic !march=rv32icv !march=rv32imc !march=rv32imcv !mabi=ilp32;rv32ic/ilp32 march=rv32ic !march=rv32icv !march=rv32imc !march=rv32imcv mabi=ilp32; *multilib_defaults: march=rv64imafdc mabi=lp64d *multilib_matches: march=rv32ic march=rv32ic;march=rv32icv march=rv32icv;march=rv32imc march=rv32imc;march=rv32imcv march=rv32imcv;mabi=ilp32 mabi=ilp32; IssuesCaso esteja tendo algum problemas com esta vers√£o especifica do GCC, h√° duas op√ß√µes, deixar detalhes do problemas no coment√°rio abaixo, ou usar a vers√£o oficial.Refer√™ncias https://github.com/RISCuinho/riscv-gnu-toolchain https://gcc.gnu.org/install/configure.html" }, { "title": "Teste Chocopy", "url": "/posts/teste_chocopy/", "categories": "programa√ß√£o, chocopy", "tags": "exemplos, python, chocopy, assembly, venus", "date": "2021-06-27 20:00:01 -0300", "snippet": "Exemplo para teste.Problemas de compatibilidade com jekyll resolvidos (jekyll-plugin-search), por√©m agora h√° um problema quanto a carga do layout e estilo/css.# Search in a listdef contains(items:[int], x:int) -&amp;gt; bool: i:int = 0 while i &amp;lt; len(items): if items[i] == x: return True i = i + 1 return Falseif contains([4, 8, 15, 16, 23], 15): print(&quot;Item found!&quot;) # Prints thiselse: print(&quot;Item not found.&quot;)" }, { "title": "Exemplo Instru√ß√µes Branch", "url": "/posts/Instrucoes_branch/", "categories": "exemplos", "tags": "assembly, codigos, exemplos, addi, bne, beq, meneumonico, b-type", "date": "2021-06-26 13:00:00 -0300", "snippet": "Instru√ß√µes do tipo Branch no Assembly Risc-V, ou qualquer outro Assembly s√£o usadas para construir algortimos similares a ‚ÄúIf‚ÄùO Exemplo abaixo foi criado abaixo foi criado pelo professor Fearghal Morgan da univeridade Nacional de Ireland em Galway e foi disponibilizada no curso de RISC-V no site https://vicilogic.com.bne rs2, rs1, imm Esta instru√ß√£o faz uma ramifica√ß√£o relativa do c√≥digo (quanto ao PC corrente), se rs2 n√£o for igual a rs1.Decomposi√ß√£o da instru√ß√£o bne x1, x0, decrAndBNELoop, veja que neste exemplo o endere√ßo destino √© representado por um label, assim ele √© substituido pelo endere√ßo relativo ao PC, o c√≥digo para esta instru√ß√£o gerado neste exemplo √©: 0xfe009ee3 B-type imm(12¬¶10:5) rs2 rs1 funct3 imm(4:1¬¶11) opcode hex (0x): ¬† 0 0 0 1 ¬† ¬† 6 3 bin (ob): (1 111 111) (0 0000) (0000 1) (001) (1110 1) (110 0011) No caso das instru√ß√µes do tipo B (B-Type) a composi√ß√£o do valor Imediato (Imm) √© um pouco mais complexa, como pode ver ele est√° espalhado pelo c√≥digo da instru√ß√£o, assim ele precisa ser montado, veja abaixo: 12 11 10:5 4:1 1 1 111 111 1110 O bit 0 do imediato √© sempre o valor 0, j√° que n√£o √© preciso ser informado, o bit 2 n√£o seria importante, por√©m temos a extens√£o compacta RV32C, neste caso o contador de endere√ßo contabiliza a cada 2 bytes, mas quando RV32I e outras a contagem √© feita a cada 4 bytes.imm(12:1) = 1 1 111 111 1110imm(0) = 0imm(12:0) = 1 1 111 111 1110 0 = 1 1111 1111 1100 = 0x1ffcextImm = 0xfffffffc# assembly program # Notes¬†¬†(default imm format is decimal 0d)start:addi x1, x0, 3loop1: addi x1, x1, -1 bne x1, x0, loop1beq x0,x0, startDepois que voc√™ faz o assembly do programa acima no Venus, voc√™ obtem a seguinte listagem: PC Machine Code Basic Code Original Code 0x0 0x00300093 addi x1 x0 3 addi x1, x0, 3 0x4 0xFFF08093 addi x1 x1 -1 addi x1, x1, -1 0x8 0xFE009EE3 bne x1 x0 -4 bne x1, x0, loop1 0xc 0xFE000AE3 beq x0 x0 -12 beq x0,x0, start O Dump do mesmo assembly gera o seguinte programa bin√°rio com 4 instru√ß√µes.00300093fff08093fe009ee3fe000ae3" }, { "title": "Extens√µes Padr√£o", "url": "/posts/extensoes_padrao/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, isa, 32bits, 64bits, 128bits", "date": "2021-06-26 10:00:00 -0300", "snippet": " Nome Descri√ß√£o Vers√£o Status Total de Instru√ß√µes RV32I Base Integer Instruction Set - 32-bit 2.1 Frozen 49 RV32E Base Integer Instruction Set (embedded) - 32-bit, 16 registers 1.9 Open Same as RV32I RV64I Base Integer Instruction Set - 64-bit 2.0 Frozen 14 RV128I Base Integer Instruction Set - 128-bit 1.7 Open 14 M Standard Extension for Integer Multiplication and Division 2.0 Frozen 8 A Standard Extension for Atomic Instructions 2.0 Frozen 11 F Standard Extension for Single-Precision Floating-Point 2.0 Frozen 25 D Standard Extension for Double-Precision Floating-Point 2.0 Frozen 25 G Shorthand for the base and above extensions n/a n/a n/a Q Standard Extension for Quad-Precision Floating-Point 2.0 Frozen 27 L Standard Extension for Decimal Floating-Point 0.0 Open Undefined Yet C Standard Extension for Compressed Instructions 2.0 Frozen 36 B Standard Extension for Bit Manipulation 0.90 Open 42 J Standard Extension for Dynamically Translated Languages 0.0 Open Undefined Yet T Standard Extension for Transactional Memory 0.0 Open Undefined Yet P Standard Extension for Packed-SIMD Instructions 0.1 Open Undefined Yet V Standard Extension for Vector Operations 0.7 Open 186 N Standard Extension for User-Level Interrupts 1.1 Open 3 H Standard Extension for Hypervisor 0.0 Open 2 S Standard Extension for Supervisor-level Instructions 1.12 Open 7 Compondo multiplas extens√µesAs extens√µes acima podem ser compostas formando processadores especializados ou de uso especificos direcionados. O processador mais generico √© a RV32G que √© composto pelas extens√µes IMFAD, se for 64 bits √© RV64G e se for 128 bits √© RV128G.As demais extens√µes devem ser referidas mantendo a mesma ordem que √© listada na tabela acima, portando o correto √© usar RV32GJVN, e n√£o RV32JNVG." }, { "title": "Extens√£o padr√£o para opera√ß√µes com vetores", "url": "/posts/extensao_padrao_operacoes_com_vetores/", "categories": "extensoes, rv32v", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, rv32v, extensoes, vetores, isa, 32bits, 64bits, 128bits, machine learning, criptografia, vector machine", "date": "2021-06-26 10:00:00 -0300", "snippet": "No dia de escrita deste artigo, a extens√£o para opera√ß√µes com vetores tinha o release est√°vel [v1.0-rc] (https://github.com/riscv/riscv-v-spec/releases/tag/v1.0-rc1). Este release √© candidato a se tornar a vers√£o v1.0 (frozen spec) para revis√£o p√∫blica.Vers√£o/Revis√£oO Projeto RISCuinho est√° trablando focado na revis√£o V1.0-rc1 que est√° aberta para revis√£o p√∫blica.Exemplo de codigo usando RV32V .text .balign 4 .global strcpy # char* strcpy(char *dst, const char* src)strcpy: mv a2, a0 # Copy dst li t0, -1 # Infinite AVLloop: vsetvli x0, t0, e8, m8, ta, ma # Max length vectors of bytes vle8ff.v v8, (a1) # Get src bytes csrr t1, vl # Get number of bytes fetched vmseq.vi v1, v8, 0 # Flag zero bytes vfirst.m a3, v1 # Zero found? add a1, a1, t1 # Bump pointer vmsif.m v0, v1 # Set mask up to and including zero byte. vse8.v v8, (a2), v0.t # Write out bytes add a2, a2, t1 # Bump pointer bltz a3, loop # Zero byte not found, so loop ret" }, { "title": "Single-Precision Floating-Point", "url": "/posts/extensao_padrao_single-precision_floating-point/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, isa, 32bits, 64bits, 128bits, single-precision, floating-point", "date": "2021-06-26 09:40:00 -0300", "snippet": "" }, { "title": "Standard Extension for Integer Multiplication and Division", "url": "/posts/extensao_padrao_multiplicacao_divisao_de_inteiros/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, 64bits, 128bits, inteiros, multiplicacao, divisao, isa", "date": "2021-06-26 09:40:00 -0300", "snippet": "" }, { "title": "Standard Extension for Atomic Instructions", "url": "/posts/extensao_padrao_instrucoes_atomicas/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, 64bits, 128bits, isa, atomic instructions", "date": "2021-06-26 09:40:00 -0300", "snippet": "" }, { "title": "Double-Precision Floating-Point", "url": "/posts/extensao_padrao_double-precision_floating-point/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, 64bits, 128bits, double-precision, floating-point", "date": "2021-06-26 09:40:00 -0300", "snippet": "" }, { "title": "Extens√£o de agrega√ß√£o", "url": "/posts/extensao_de_agregacao/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, 64bits, 128bits, isa", "date": "2021-06-26 09:40:00 -0300", "snippet": "A Extens√£o RV32G √© defina apenas para ser uma apelido para um grupo especifico de extens√£o que comp√µem um processador funcional.A extens√µes que comp√µem o RV32G s√£o: RV32M - Standard Extension for Integer Multiplication and Division RV32A - Standard Extension for Atomic Instructions RV32F - Standard Extension for Single-Precision Floating-Point RV32D - Standard Extension for Double-Precision Floating-Point" }, { "title": "Base Integer Instruction Set - 32-bit", "url": "/posts/base_integer_instruction_set_-_32bit/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, instrucoes, isa", "date": "2021-06-26 09:40:00 -0300", "snippet": "Conjunto de instru√ß√µes base para RISC-V, abaixo listo as instru√ß√µes que devem ser implementadas inicialmente numa implementa√ß√£o base RISC-V de 32 bits, as extens√µes 64 e 128, devem ter instru√ß√µes extras com ajustes para as respectivas extens√µes." }, { "title": "Registradores Risc-V", "url": "/posts/registradores_no_risc-v/", "categories": "registradores", "tags": "assembly, registradores", "date": "2021-06-26 08:00:00 -0300", "snippet": "Um Risc-V possui 32 registradores que podem ser usados livremente, por s√£o chamados de registradores de proposito geral, por√©m existe uma padroniza√ß√£o atr√°ves do ABI (Application Binary Interface) onde cada registrador recebe um nome e um uso, assim facilita uma maior integra√ß√£o no desenvolvimento de aplica√ß√µes. Esta padroniza√ß√£o facilita em muito o desenvolvimento em C.Registradores de Uso GeralNa Tabela abaixo apresento os registradores de uso geral e seu nome padr√£o, o nome ABI, e sua descri√ß√£o Registrador Nome ABI Descri√ß√£o Quem Grava x0 zero Fisicamente conectado a zero ¬† x1 ra Endere√ßo de Retorno Origem chamada x2 sp stack pointer Destino chamada x3 gp Ponteiro Global - x4 tp Ponteiro Thread - x5-7 t0-2 Registradores Tempor√°rios Origem Chamada x8 s0 / fp Registradore Preservado/Ponteiro de Frame Destino Chamada x9 s1 Resitrador Preservado Destino Chamada x10-11 a0-1 Argumentos de Fun√ß√£o/Valores de Retorno Origem Chamada x12-17 a2-7 Argumentos de Fun√ß√£o Origem Chamada x18-27 s2-11 Registradores Preservados Destino Chamada x28-31 t3-6 Registradores Temporarios Origem Chamada Registradores EspecificosNa exten√ß√£o padr√£o RV32I al√©m dos 32 registradores de proposito geral, h√° mais um registrador de uso especifico para uso do Programa Counter, ele √© de uso interno e contem o valor do Program Counter, para ter acesso ao seu valor veja instru√ß√µes AUIPC, JAL, JALR e detalhes nos artigos de exemplos.Registradores e Extens√µesAs exten√ß√µes que alteram os comprimentos de bits do processador RISC-V de 32bits para 64 e 128, n√£o alteram o n√∫mero de registradores, apenas seu comprimento, portando o n√∫mero de registradores neste tipo de exten√ß√£o n√£o alteara. Sendo assim os registradores sendo todos de 32bits, passam respectivamente a ser de 64 bits e 128 bits.No caso da exten√ß√£o RV32E que √© para Embarcados, o n√∫mero de registradores √© reduzido para 16, mas o comprimento dos mesmo √© mantido em 32 bits.Algumas extens√µes podem adicionar novos registradores, n√£o irei tratar aqui estes registradores, veja artigos relativos na tag registradores." }, { "title": "Configurando o GTKwave", "url": "/posts/configurando_gtkwave/", "categories": "gtkwave", "tags": "gtkwave, vcd, test, analise, verilog", "date": "2021-06-24 23:40:00 -0300", "snippet": "Projetar hardware nos tempos atuais demandam simula√ß√µes, n√£o partimos apenas de calculos e ideias, sem d√∫vida estes s√£o os primeiros passos, mas durante a simula√ß√£o precisamos ter m√©todos para analisar os sinais gerados e a ferramenta GTKWave √© a melhor e mais consagrada para tal tarefa, √© capaz de carregar diversos formatos de arquivos, sendo o formato VCD (Value Change Dump) o mais comum.Instalando o GTKWavepara instalar o GTKWave n√£o h√° segredo, no linux basta usar o comando de instala√ß√£o nativo de sua distribui√ß√£o, no caso das variantes Debian que usam apt-get basta usar apt-get install gtkwave.Para Windows voc√™ pode fazer o donwload em https://sourceforge.net/projects/gtkwave/files/ e fazer o procedimento padr√£o de instala√ß√£o.VCD (Value Change Dump)N√£o irei entrar em detalhes do formato VCD nesta publica√ß√£o, quem sabe no futuro escrevo algo sobre o assunto, fique de olho no site na tag VCD, ou no forum do RISCuinho na p√°gina de exemplos.Um bom lugar para ler sobre este formato de arquivo, √© no site ZipCPU, no artigo ‚ÄúWriting you own VCD file‚Äù.Usando o GTKWave com o RISCuinho.Ap√≥s clonar o core do RISCuinho voc√™ pode usar o GTKWave para ver os sinais, para isso mude para o branch beta_0.x, digite o comando make normalmente ele ir√° executar um teste de simula√ß√£o padr√£o da situa√ß√£o corrente do core, ent√£o ele criara um arquivo RISCuinho.vcd, voc√™ pode editar este arquivo para se familiar com seu conte√∫do. Em seguida basta executar o comando make gtkwave, execute este comando apenas uma vez, ele ir√° abrir o gtkwave para voc√™ j√° configurado corretamente, voc√™ poder√° alterar as configura√ß√µes e sinais que deseja visulizar arrastando os sinais para a caixa da direita, depois voc√™ pode ir no menu: File &amp;gt; Write Save File ou pode usar a combina√ß√£o [CTRL + S] assim ir√° salvar um arquivo de nome RISCuinho.gtkw na raiz do projeto, e quando chamar novamente o comando make gtkwave o gtkwave ir√° ser carregado novamente com as configura√ß√µes salvas e o arquivo vcd do RISCuinho.Veja cada vez que chamar make gtkwave ele ir√° abrir uma nova inst√¢ncia do GTKwave.Conforme forem postando d√∫vidas no [Forum do RISCuinho]((https://github.com/RISCuinho/exemplos/discussions) ou nos [Issues]((https://github.com/RISCuinho/core/issues) amplio os artigos e tutoriais.Formata√ß√£o de Tela do GTWaveO GTKwave foi formatado para grandes monitores, e pode ser um pouco desconfort√°vel em telas pequenas, ao meu modo de ver considero qualquer tela menor que 21 olegadas uma tela pequena, portanto segue uma sugest√£o para melhorar a visualiza√ß√£o dos sinais em monitores de 15 polegadas com baixa resolu√ß√£o.Abaixo apresento os parametros que uso em minha esta√ß√£o Linux de trabalho, como ela usa a resolu√ß√£o de 1028x800 em um monitor de 15.4‚Äù reduzir o tamanho da fonte para 8 pixels e optei pela fonte Monospace que me permite uma visualiza√ß√£o mais estruturada dos valores.splash_disable onuse_nonprop_fonts 1use_big_fonts 0use_pango_fonts onfontname_signals Monospace 8fontname_waves Monospace 8fontname_logfile Screen 8editor &quot;subl3 %s&quot;enable_horiz_grid 0use_fat_lines 1" }, { "title": "Clonando o Core RISCuinho", "url": "/posts/Clonando_o_Core_Riscuinho/", "categories": "core", "tags": "core, clone, git, github, analise, verilog, hdl, desenvolvimento, colaborando", "date": "2021-06-24 23:40:00 -0300", "snippet": "Para obter uma c√≥pia do projeto RISCuinho voc√™ deve come√ßar pelo Core do processador, assim voc√™ deve clonar o repositore que se encontra no endere√ßo https://github.com/RISCuinho/core, caso n√£o tenha conhecimento do Git ou do GitHub sugiro come√ßar pelo estudo do GIT no pr√≥prio site, n√£o precisa dominar 100% a ferramenta, apenas os comandos b√°sicos: clone pull diffConhecendo estes comandos, voc√™ j√° poder√° se manter atualizado e ver as novidades sem ter que ficar visitando o site do GitHub, mas para contribuir com o projeto voc√™ precisa conhecer mais 3 comandos: push add commitClonando o projetoPara clonar o projeto basta voc·∫Ω criar uma pasta de trabalho e nela digitar o seguinte comando:git clone https://github.com/RISCuinho/coreEste comando ir√° fazer o download de uma copia integral de todo o trabalho publicado no GitHub, apenas do c√≥digo claro, as informa√ß√µes como issues, foruns, wiki e outros detalhes somente pelo site mesmo.Com este comando ser√° criado uma pasta de nome core, esta pasta pode ter seu nome alterado, ou ao fazer o clone voc√™ pode informar um novo nome como abaixo:git clone https://github.com/RISCuinho/core riscuinho_coreAssim ser√° criado uma pasta riscuinho_core que conter√° o clone do reposit√≥rio.Mantendo seu clone atualizado.Depois de clonar seu reposit√≥rio, voc√™ pode mante-lo sempre atualizado, para isso basta sempre que quiser entrar na pasta ‚Äúcore‚Äù ou ‚Äúriscuinho_core‚Äù ou o nome que escolheu usar, e digitar o comando:git pullLembre-se apartir de agora os demais comando devem ser digitado dentro da pasta criada que contem o clone de reposit√≥rio.Refer√™ncias Manual do Git Manuais do GitHub" }, { "title": "Forum de Exemplos", "url": "/posts/forum-exemplos/", "categories": "exemplos", "tags": "exemplos, fpga, tang nano, verilog, gowin, forum", "date": "2021-06-24 15:40:00 -0300", "snippet": "‚û°Ô∏è Para viabilizar o debate de exemplos estamos disponibilizandos o recurso de Discuss√£o, assim podemos interconectar ideias e membros de nossa comunidade, esperamos com isso que voc√™: Compartilhe Ideias; Apresente suas d√∫vidas; Se envolva com outros membros da comunidade; Convide outros a se tornarem membros e que sejam de mente aberta e com os mesmos ideias de compartilhar conhecimento e torna-lo mais democr√°tico e acess√≠vel a todos sem distin√ß√£o de classe, g√™nero, cor, ra√ßa e nacionalidade, valorizando a produ√ß√£o nacional por uma quest√£o de patriotismo. üí™.üì¢ Para come√ßar, fa√ßa um coment√°rio abaixo se apresentando, falando de suas ideias üí° e o que tem feito com o RISC-V e como pode colaborar com nosso projeto principalmente. Lembre-se de colocar os links üîó para seu perfil assim voc√™ divulga seu curr√≠culo caso isso seja importante." }, { "title": "Alem do Led Blink com a Tang Nano", "url": "/posts/Alem_do_Led_Blink_com_a_Tang_Nano/", "categories": "exemplos", "tags": "exemplos, fpga, tang nano, verilog, gowin", "date": "2021-06-20 18:40:00 -0300", "snippet": "Al√©m do Led Blink com a TangNano, controlando um contador com um m√≥dulo de Som: https://www.twitch.tv/videos/1016278140TangNano: https://s.click.aliexpress.com/e/_99IQiPCabo USB Tipo C: https://s.click.aliexpress.com/e/_AkN3ALModulo de Sensores: https://s.click.aliexpress.com/e/_AeBgzRAs lives est√£o um pouco confusas pois a ferramenta picou a transmiss√£o em v√°rias, assim que puder irei melhorar e organizar, no momento estou sem computador adequado a este trabalho, ent√£o n√£o d√° para regravar os videos fazendo um tutorial mais resumido, ou edita-los de forma a focar no conte√∫do.Portando abaixo vai os videos principais:" }, { "title": "Exemplo ADDi", "url": "/posts/ADDi/", "categories": "exemplos", "tags": "assembly, codigos, exemplos, addi, meneumonico, dump, i-type", "date": "2021-06-18 22:00:00 -0300", "snippet": "Abaixo apresento exemplo de uso da instru√ß√£o ADDi, esta instru√ß√£o faz a adi√ß√£o de um valor imediato (imm) a um registrador (rs1) e grava em outro ou no mesmo registrador (rd).addi rd, rs1, imm, rd = rs1 + immEstes exemplos foi obtido no tutorial: https://www.vicilogic.com/vicilearn/run_step/?s_id=1452exemplo addi x3, x3, 5decomposi√ß√£o da instru√ß√£o `addi x3, x3, 5. I-type imm(11:0) rs1 f3 rd opcode hex (0x): [ 0 0 5 ] 0 3 0 0 3 1 3 bin (0b): [0000 0000 0101] [0 0011] [000] [0 0011] [001 0011] Ou seja:OpCode: 0x13SubFun√ß√£o (f3): 0x00Valor Imediato: 0x005Registrador Origem: 0x03Registrador Destino: 0x03O OpCode e a fun√£o identificam a opera√ß√£o que ser√° realida no caso Soma de um valor Imediato (0x005) a um Registrador (X03).Exemplo de C√≥digoO c√≥digo foi obtido no video tutorial da Vicilogic https://www.vicilogic.com/vicilearn/run_step/?s_id=1452C√≥digo Assembly:# assembly program # Notes (default imm format is decimal 0d)main:addi x3, x3, 5 # x3 = x3 + 5 addi x3, x3, 5 # x3 = x3 + 5 addi x3, x3, 5 # x3 = x3 + 5 O c√≥digo abaixo foi obtido colando o assembly acima na ferramenta Venus PC instruction (31:0) basic assembly code original assembly code Notes 00 0x00518193 addi x3 x3 5 addi x3, x3, 5 # x3 = x3 + 5 04 0x00518193 addi x3 x3 5 addi x3, x3, 5 # x3 = x3 + 5 08 0x00518193 addi x3 x3 5 addi x3, x3, 5 # x3 = x3 + 5 ‚Äòdump‚Äô do programa em binario no simulador Venus. N√∫mero de Instru√ß√µes = 3005181930051819300518193Refer√™ncia https://riscuinho.github.io/venus/" }, { "title": "Usando o Python como ferramenta de apoio", "url": "/posts/usando_python/", "categories": "ferramentas", "tags": "ferramenta, python, python3, chocopy, debug, dump, vcd, venv", "date": "2021-06-18 18:40:00 -0300", "snippet": "O Python √© usado no RISCuinho como ferramenta para ajudar nos testes, e tamb√©m para ajudar a ensinar a programa√ß√£o assembler, mas neste post iremos falar da instala√ß√£o de forma geral e em seguida com o foco para uso nos testes.Primeiro instale o Python3 e o pip3 em seu ambiente de trabalho como sugere os melhores artigos na internet, n√£o irei entrar neste detalhe aqui pois h√° muitos artigos bons sobre isso e √© uma tarefa muito simples.Em seguida crie um ambiente virtual para ele, onde ir√° instalar as bibliotecas especificas para uso no RISCuinho, por padr√£o convencionei que este ambiente virtual se chamar√° python_riscuin. Portanto basta digitar o comando abaixo na pasta ‚Äúcore‚Äù do projeto do RISCuinho. Voc√™ pode fazer isso tamb√©m no Workspace onde trabalha nos projetos do RISCuinho se preferir.python3 -m venv python_riscuinAgora voc√™ deve ativar este ambiente para que os passos das se√ß√µes a seguir sejam executados adequadamente e n√£o interfiram na sua intala√ß√£o Python de seus ambiente geral.. ./python_riscuin/activatecom este comando executado, sua linha de comando fica prefixada:(python_riscuin) ~/workspace/RISCuinho/core$ Instalando ferramentas para trabalhar com o VCDO VCD √© um tipo de arquivo muito importante na depura√ß√£o de projetos de design de hardware, ele √© gerado pelas ferramentas de simula√ß√£o Verilog, como o iVerilog e com o python podemos processa-los e analisar se tudo est√° correto como desejamos.Iremos usar em nossos testes o VCDVCD, para instala-lo √© preciso tamb√©m a biblioteca importlib_resources, use o comando a seguir:(python_riscuin) ~/workspace/RISCuinho/core$ pip install importlib_resources vcdvcdConsiderando que voc√™ j√° andou fazendo testes com o RISCuinho √© bem certo que voc·∫Ω tem um arquivo de extens√£o .vcd dentro da pasta core onde clonou o projeto de mesmo nome, se n√£o tiver entre nesta pasta, se n√£o estiver nela, e execute o comando make ele ir√° executar o iverilog e gerar um novo arquivo RISCuin.vcd.Agora para testar se tudo est√° ok, basta digitar o comando:(python_riscuin) ~/workspace/RISCuinho/core$ vcdcat RISCuin.vcd |lessVeja nesta primeira intera√ß√£o usei o less, para facilitar, pois o riscuinho nesta vers√£o tem mais de 170 sinais disponiv√©is (gerando linhas com 800 colunas), al√©m de ter pelo menos 300 linhas s√≥ no exemplo com 3 instru√ß√µes addi, ent√£o escolhi alguns sinais e vou apresenta-los de uma forma diferentte, com o comando a seguir apenas quando eles se alteram:(python_riscuin) ~/workspace/RISCuinho/core$ vcdcat -x RISCuin.vcd time RISCuin_tb.finish_rst RISCuin_tb.start_rst RISCuin_tb.rst RISCuin_tb.pc_end RISCuin_tb.cpu.pc_enable -do comando acima lista expecificamente os sinais indicados -x e apenas os apresenta quando v√°riam de valor -d (delta), experimente o comando sem o delta.Mais tarde trago mais informa√ß√µes sobre o uso do VCDVCD." }, { "title": "Global Offset Table", "url": "/posts/global_offset_table/", "categories": "assembly", "tags": "assembly, got, pic, pie", "date": "2021-06-18 18:40:00 -0300", "snippet": "A ‚ÄúGlobal Offset Table‚Äù, ou GOT, √© uma se√ß√£o da mem√≥ria do programa (execut√°vel ou biblioteca compartilhada) usada para abilitar o programa compilado como ELF para que seja executado corretamente, independente do endere√ßo de mem√≥ria que o programa ou dado foi carregado no runtime.Seu mapa de s√≠mbolos no c√≥digo de programa, corresponde ao endere√ßo absoluto de mem√≥ria para facilitar o Position Independent Code (PIC) e Position Independent Executables (PIE) que s√£o carregados para diferentes endere√ßos de mem√≥ria cada vez que o programa √© iniciado. O endere√ßo de runtime de mem√≥ria, tamb√©m conhecido como endere√ßo absoluto de mem√≥ria de variaves e fun√ß√µes √© conhecido antes do programa ser inciado quando PIC ou PIE do codigo √© executado para n√£o ser hardcoded durante a compila√ß√£o pelo compilador.O Global Offset Table √© representado pelas se√ß√µes .got e .got.plt nos arquivos ‚ÄúELF‚Äù que s√£o carregados na mem√≥ria de programa na inicializa√ß√£o. O dynamic linker do sistema operacinal √© usado para atualizar a realoca√ß√£o do ‚Äúglobal offset table‚Äù (simbolos para endere√ßos de mem√≥ria absoluta) quando o programa √© inicializado ou os simbolos s√£o acessados. √â um mecanismo que permite bibliotecas compartilhadas (.so) ser realocadas para diferntes endere√ßos de mem√≥ria no inicio do programa evitar conflitos de endre√ßos do programa principal ou outras bibliotecas compartilhadas, e evitar t√©cnicas de invas√£o como ‚Äúexploits‚Äù." }, { "title": "Inaugurando Novo Site", "url": "/posts/Inaugurando_Novo_Site/", "categories": "site", "tags": "site", "date": "2021-06-18 18:40:00 -0300", "snippet": "RISCuinho - A scratch in the possibilities in the universe of microcontrollersRISCuinho (Risquinho), in portuguese is a small scratch on the surface of something, and this represents the proposal of this project that starts in a very didactic way, doing the minimum necessary by scratching the surface of what can be done with a Core or multiple RISC Cores.This project is educational and aims at my study on microprocessors and to teach my introductory courses on microprocessor programming and architecture at Arduino Minas (Curso Maker/Geringon√ßa Maker Space). RISCuinho (Risquinho) will also be used for my RTOS studies when it is possible to multiply its core to simulate multicore microcontrollers.I am a autodidata student I do not have a computer science course and no course that gives me the basis to create such a microcontroller, however I am graduated in Computer Network Design and Implementation, I have some programming courses, Project Management and other related areas, I used to create it was through studies of specialized books such as those discussed in the bibliography section and on websites on the internet.All this material was assimilated with the help of conversations in the RISC-V Brasil group on Telegram, where participants from different areas related to IT and exchange experience on microprocessors and microcontrollers, some renowned professionals in the sector, which I am very grateful in the sector, in particular: Marcelo Samsoniuk (@samsoniuk) Core Risc DarkRiscv Paulo Matias (@thotypous) Lucas Teske (@racerxdl) Core RISC RISCow Marcus Medereiros (@zxmarcos) Core RISC Riscado-V Jecel JrI will use Portuguese as the official language of this project, but English can also be used for requests for information and suggestions.Eu usarei o portugu√™s como idioma oficial deste projeto, por√©m o ingl√™s tamb√©m pode ser usado para solicita√ß√µes de informa√ß√µes e sugest√µes.Arquitetura do MicrocontroladorO RISCuinho (Risquinho) usa aa Arquitetura Havard simples, com a mem√≥ria de programa espelhada no endere√ßo de mem√≥ria de dados, para que possa ser reprogramada a aquente e demonstrar recursos modernos de microcontroladores que possuem tal recurso, isso ser√° discutido futuramente em documenta√ß√£o apropriada.O RISCuinho possui 32 registradores conforme a especifica√ß√£o RV32I. Possui todas as intru√ß√µes b√°sicas para opera√ß√£o com numeros inteiros implementadas. Ele n√£o possui instru√ß√µes de Sistema, Sincronismo e Controle implementadas nesta vers√£o.O RISCuinho tamb√©m √© um core de um 3 est√°gio de um √∫nico ciclo de clock, em vers√µes futuras ser√° desenvolvido um pipeline mais complexo.ExemplosA pasta examples, no projeto core do RISCuinho, descrita aqui na categoria ‚Äúexemplos‚Äù, possui exemplos para testes, na sua maioria obtidos no curso oferecido pela [Vicilogic][https://www.vicilogic.com/], tais exemplos podem ser obtidos no link https://www.vicilogic.com/vicilearn/run_step/?s_id=1452, para detalhes de cada exemplo que foi usado pra teste, entre no anterior.Simula√ß√£oAs Simula√ß√µes est√£o sendo feitas com IVerilog no Windows 10 com WSL, a condifica√ß√£o √© feita no VSCode, e a verifica√ß√£o dos sinais gerados com GTKWave.As instru√ß√µes s√£o testadas tanto no ambiente Vicilogic como no simulador emulsiVSintese e HardwareEstou escolhendo algumas ferramentas mais populares e consagradas para sintetizar o RISCuinho e coloca-lo funcionando em um FPGA f√≠sico, abaixo listo algumas informa√ß√µes sobre isso.GoWinGoWin √© uma empresa de semicondutores chinesa que produz uma linha facinante de FPGA com uma abordagem bastante intrigante que tem causando bastante embara√ßo na comunidade, j√° que com sua abordagem consegue reduzir dr√°sticamente o uso de LUTs, pois vem dotado de um grande n√∫mero de recursos como ALUs e registradores.Ainda estou me familiarizando com ela, mas j√° descobrindo que pode ser uma grande aliada para o RISCuinho.TangNanoTangNano √© uma placa de prototipa√ß√£o que vem empoderada com um FPGA GW1N-LV1QN48C6/I5, equipado com 1152 LUT4, 1 PLL e um total de 72Kbit SRAM em 4 Block, enpacotado numa QFN48.A TangNano disponibiliza todas as portas de forma bem acess√≠vel.Tamb√©m vem com uma PSRAM de 64MBits e possui um conector para LCD RGB e a pinagem para uso com VGA, j√° vem conectada a um LED RGB tamb√©m. Al√©m de um cristal de 24Mhz, porta USB Type-C e JTAG.QuartusEstou usando o Quartus 20.4 Prime Lite Edtion para fazer os testes em uma placa De0-nano.De0-NanoPlaca de prototipa√ß√£o e estudos da Terasic.Estou usando a De0-nano vers√£o 1.6: FPGA: Altera Cyclone IV EP4CE22FE22F17C6N" } ]

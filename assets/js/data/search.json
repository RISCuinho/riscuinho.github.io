[ { "title": "ABI - Integer, Long, Pointer (ILP)", "url": "/posts/ABI_Inteiros_Longos_Pointers/", "categories": "abi", "tags": "abi, ilp, ilp32, ilp32f, ilp32d, ilp64, ilp64f, ilp64d, application binary interface, integer, long, pointer, float, float point, soft float point, hard float point", "date": "2021-08-11 18:40:00 -0300", "snippet": "ILP é um termo que se refere a como o compilador trata os números Inteiros, Longos e os Ponteiros, qual seu comprimento e como são armazenados e manipulados internamente quando manipulados pelo Assembly, são arquiteturas ABI (Application Binary Interface), veremos aqui também que pontos flutuantes também são tratados neste ABI quando a são pós-sufixados com f ou d.Conforme o Guia Prático RISC-V, página 44 (69), “Os compiladores RISC-V suportam várias ABIs, dependendo se as extensões F e D estão presentes. Para o RV32, as ABIs são denominadas ilp32, ilp32f e ilp32d. ilp32 significa que os tipos de dados de linguagem C int, long e pointer são todos de 32 bits; o sufixo opcional indica como os argumentos de ponto flutuante são passados. No ilp32, argumentos de ponto flutuante são passados em registradores de inteiros. No ilp32f, argumentos de ponto flutuante de precisão simples são passados em registradores de ponto flutuante. No ilp32d, argumentos de ponto flutuante de precisão dupla também são passados em registradores de ponto flutuante.Naturalmente, para passar um argumento de ponto flutuante em um registrador de ponto flutuante, é necessário a extensão de ponto flutuante F ou D da ISA (consulte o Capítulo 5). Para compilar o código para o RV32I (GCC flag ‘-march=rv32i’), você deve usar o ABI ilp32 (GCC flag ‘-mabi=ilp32’). Por outro lado, ter instruções de ponto flutuante não significa que a convenção de chamada deva utilizá-las; Assim, por exemplo, o RV32IFD é compatível com todas as três ABIs: ilp32, ilp32f e ilp32d.O linker verifica se a ABI do programa corresponde a todas as suas bibliotecas. Embora o compilador tenha suporte muitas combinações de extensões ISA e ABIs, apenas alguns conjuntos de bibliotecas podem ser instalados. Assim, um erro comum é vincular um programa sem ter as bibliotecas compatíveis instaladas. O linker não produzirá uma mensagem de diagnóstico útil nesse caso; ele tentará simplesmente vincular-se a uma biblioteca incompatível e, em seguida, informará a incompatibilidade. Esse erro geralmente ocorre apenas quando compila-se em um computador para um computador diferente (cross compiling).”" }, { "title": "Atributos de Propriedades", "url": "/posts/atributos/", "categories": "hdl", "tags": "hdl, atributos, verilog, propriedades", "date": "2021-08-08 18:40:00 -0300", "snippet": "Os atributos foram adicionados no Verilog 2001 para definir propriedades especiais de algum objeto ou declaração para uso em simuladores e sintetizadores. Porém o Verilog 2001 não especifica quais atributos devem ser declarados, isso é definido pela ferramenta ou outros padrões.Podem ser usados como prefixo de alguma declaração, itens do módulo, conexões de porta. E como sufixo para um operador ou chamada a função.Atributos que não tem valor designado tem o valor “1” como padrão. Multiplos atributos são declarados como uma lista separa por vírgula.ExemplosPrefixado em uma declaração case.(* full_case, parallel_case *) case (state)endcaseSufixo para um operador.assign sum = a + (* CLA=1 *) b;iVerilogO iVerilog possui alguns atributos que são úteis para simulação e sintese, abaixo segue o original da listagem obtido no fonte do GitHub.ATTRIBUTE NAMING CONVENTIONSAttributes that are specific to Icarus Verilog, and are intended to beof use to programmers, start with the prefix “ivl_”.Attributes with the “ivl” prefix are set aside for internaluse. They may be generated internally by the compiler. They need notbe documented here.ATTRIBUTES TO CONTROL SYNTHESISThe following is a summary of Verilog attributes that Icarus Verilogunderstands within Verilog source files to control synthesisbehavior. This section documents generic synthesis attributes. Fortarget specific attributes, see target specific documentation.These attributes only effect the behavior of the synthesizer. Forexample, the ivl_combinational will not generate an error messageif the Verilog is being compiled for simulation. (It may generate awarning.)Attributes for “always” and “initial” statements(* ivl_combinational *)This attribute tells the compiler that the statement modelscombinational logic. If the compiler finds that it cannot makecombinational logic out of a marked always statement, it willreport an error.This attribute can be used to prevent accidentally inferringlatches or flip-flops where the user intended combinationallogic.(* ivl_synthesis_on *)This attribute tells the compiler that the marked always statementis synthesizable. The compiler will attempt to synthesize thecode in the marked &quot;always&quot; statement. If it cannot in any waysynthesize it, then it will report an error.(* ivl_synthesis_off *)If this value is attached to an &quot;always&quot; statement, then thecompiler will *not* synthesize the &quot;always&quot; statement. This can beused, for example, to mark embedded test bench code.Attributes for modules(* ivl_synthesis_cell *)If this value is attached to a module during synthesis, thatmodule will be considered a target architecture primitive, andits interior will not be synthesized further. The module cantherefore hold a model for simulation purposes.Attributes for signals (wire/reg/integer/tri/etc.)(* PAD = “&quot; *)If this attribute is attached to a signal that happens to be aroot module port, then targets that support it will use the stringvalue as a list of pin assignments for the port/signal. The formatis a comma separated list of location tokens, with the format ofthe token itself defined by the back-end tools in use.Other Attributes[ none defined yet ]MISC(* _ivl_schedule_push *)If this attribute is attached to a thread object (always orinitial statement) then the vvp code generator will generate codethat causes the scheduler to push this thread at compile time. Thecompiler may internally add this attribute to always statements ifit detects that it is combinational. This helps resolve time-0races." }, { "title": "Programming Language Interface (PLI)", "url": "/posts/Programming_Language_interface/", "categories": "programacao, verilog", "tags": "pli, verilog, programacao", "date": "2021-07-08 08:40:00 -0300", "snippet": "programming Lanaguage Interface (PLI) é um mecanismo qe fornece uma interface de programa com a aplicação (Application Program Interface - API) para o Verilog. Em essência ele é um mecanismo para invocar funções escritas em linguagem C a partir do código escrito em Verilog. A construção que invoca a rotina PLI no código Verilog é normalmente chamado de uma “system call” (Chamada de Sistema), se for definida internamente no simulador, e “user-defined task” ou “function”, se ela é escrita pelo usuário.Tanto para o System Call quanto para User-defined task o mecanismo básico de funcionamento permanece o mesmo para o PLI, ortanto sempre usarei o termo System Call para fazer referẽncia a tal recurso de chamda.Chamadas como $display, $monitor, $finish são System Calls internas de qualquer simulador. Podemos vir a encontrar outras especificas o que é raro.O PLI é usado para fazer tarefas que normalmente o Verilog não faria, como caregar um arquivo para um registrador, ou gravar noutro arquivo a situação de sinais especificos para depuração. Podemos também descrever modelos funcionais, calcular atrasos e obter informações de designer como a hierarquia de instãnciação dos dos módulos." }, { "title": "Diferenças entre BigEndian, Little Endian e Bit Endianness", "url": "/posts/Diferencas_entre_BigEndian_Little_Endian_e_Bit_Endianness/", "categories": "programacao, cplusplus", "tags": "big endian, little endian, endianness, bit endianness, lsb, msb, binário, byte, bit, numeração, endereçamento, manipulação de bits, manipulação e bytes, little end in, big end in", "date": "2021-07-07 18:40:00 -0300", "snippet": "Para o iniciante este conceito pode parecer bastante confuso, e até inútil, mas para quem deseja trabalhar com microcontroladores, processadores e principalmente redes a nível de protocolos é fundamental seu entendimento. Big Endian ou Little Endian, qual o impacto na transmissão de dados de um sistema para outro, entre o módulo e o microcontrolador?Artigo originalmente publicado no site de Carlos Delfino.O conceito de Big Endian e Little Endian, nomeado simplesmente de Endianess vem da transição dos computadores de médio porte para os microcomputadores, quando estes passaram a endereçar tantos os bits quantos os Bytes de forma diferente. Mas tal problema é principalmente observado quando lidamos com os Bytes, já que pode acarretar o embaralhamento até de texto causando confusão, mas no caso de tratamento numérica pode se tornar a falência total do sistema.O problema se deu inicio, como já foi dito quando os microcomputadores surgiram, já que estes optaram em trabalhar com o conceito de Little Endian, mas o que é este Endian? porque Big ou Little? bem Endian é um termo cunhado em uma história que faz alusão as disputas politicas e religiosas na Europa, e descrita em uma história de ficção escrita por Jonathan Swift em uma sátira escrita em 1726, Conhecida em português como as Viagens de Gulliver, conta a história, que dois grupos de cidadãos entram em guerra por não concordarem qual o lado certo se deve quebrar o ovo, do lado maior (Big End) ou do lado menor (Little End), com isso uma guerra civil se instala separando os grupos.Na informática isso não foi muito diferente, não chegamos a uma guerra civil por isso, mas tivemos os sistemas separados em “Big End in” e “Little End in” que define como os bits são transmitidos em algum sistemas, e em outros, apenas quando lidamos com palavras (World/2 bytes, DWorld/4 bytes), seja o microprocessador 8 bits ou maiores.Nos tempos atuais, não temos muitos problemas relativos a tal modo de endereçamento, porque quase todos os microprocessadores usam o Little Endian para endereçar seus dados, com exceção de alguns como o antigo PowerMAC que usava um PowerPC especial travado para BIG Endian. Os outros computadores que não usam este travamento permitem o chaveamento entre os dois modos no que tange a manipulação dos bytes.Outras arquiteturas que trabalham com Big Endian são, Motorola 68000 series (incluindo Freescale ColdFire), Xilinx Microblaze, SuperH, IBM z/Architecture, Atmel AVR32 e o Intel 8051 com atenção para instrução LCALL que endereça usando Little Endian.Mas então, o que é realmente Big Endian e Little Endian?Como já dito, nada mais é do que a forma que os bytes e bits são endereçados na memória, quando se trata de bytes o Big Endian endereça em uma palavra por exemplo do tipo 2 bytes, o primeiro byte como sendo o endereço menor, e a segunda palavra o endereço seguinte (+1 byte). Ja no Little Endian, o segundo Byte é endereçado primeiro, isso para quem está começando pode causar um certo desconforto, apesar que as linguagens abstraem para nós tal problema, mesmo no C, isso não é percebido, mas podemos vir a ter problemas quando lidamos com ponteiros e até mesmo estruturas de dados (struct), já que o primeiro endereço em um sistema Big Endian, não será a menor parte do número, ou seja a parte menos significante (LSB), mas sim a parte mais significante (MSB).Vejamos abaixo para entendermos primeiro o conceito de LSB e MSB, que trata a importância do bit ou byte na composição numérica.LSB representa a parte menos significativa do número ou seja a parte mais a direita. Least Significant bit/Byte.Já o MSB representa a parte mais significativa, ou seja a parte mais a esquerda do número. Most Significant bit/Byte.Agora podemos entender melhor o conceito Little Endian e Big Endian, vejamos primeiro a nível de bits do que se trata.Para o Little Endian a representação numérica em bits, onde o algoritmo de conversão numérico que a maioria de nós está acostumado pode ser facilmente representado na fórmula:\\[\\sum_{i=0}^{N-1} b_i \\cdot 2^i\\]Temos então a seguinte ordenação dos bits para a representação do número 180 em Little Endian, onde o bit menos significativo é tratado como sendo o bit 0 e o bit 7 é o bit mais significativo.Representação gráfica do Little EndianPara o Big Endian os bits mantem sua disposição, porém sua ordem de transmissão inverte, ou seja são endereçados do MSB como sendo o primeiro bit, e o LSB como sendo o último bit, portanto a fórmula de conversão passa a ser:\\[\\sum_{i=0}^{N-1} b_i \\cdot 2^{(N - 1 - i)}\\]Representação gráfica do Big EndianO Conceito EndianessEm se tratando de bits, o conceito Endianess afeta mais o hardware no que tange o endereçamento de memória, transferência de dados em barramentos, principalmente nos seriais, e operações de manipulação de bits. Já que, principalmente se formos usarmos máscaras do tipo bitwise é preciso saber exatamente a ordem dos bits para não haver enganos fatais.Vejamos agora como é tratado o conceito endianess quando se trata de bytes, o que afeta mais a manipulação do dado na memória, quando é representado com mais de dois bytes, por exemplo números inteiros e short int em maquinas 32 bits.As imagem abaixo representam dois números inteiros armazenado na memória de um microcontrolador qualquer que seja do tipo Little Endian, a primeira representa um número de 16bits ou seja um Word, o segundo um número de 32 bits, Double Word (DWord).Representação gráfica do Big Endian para um WordRepresentação gráfica do Big Endian para um DWordComo pode ver o byte mais significativo é armazenado no endereço mais baixo da memória, sendo então acessado primeiramente, e o byte menos significativo é armazenando posteriormente. Na representação o endereço de memória começa a contar em a.Vejamos agora como o mesmo número fica representado em um sistema Little Endian. Temos a seguir os mesmos números usados na representação anterior, porém agora utilizado o mecanismo Little Endian para armazená-lo.Representação gráfica do Little Endian para um WordRepresentação gráfica do Little Endian para um DWordHouve épocas que tal conflito quando transferindo dados entre computadores que usavam sistemas diferentes (chamdos bytesex), ou seja transmitindo de um sistema Little Endian para um sistema Big Endian a string UNIX, foi identificado como NUXI Problem, ou seja o “problema NUXI”, devido a inversão da String “UNIX”.Como pode ver a cada par de bytes, haveria uma inversão, de dos dois bytes, causando um certo transtorno.Um exemplo do formato Little Endian em CAbaixo estão dois códigos que demonstra como um número inteiro é armazenado na mémoria, o primeiro um número de 16 bits, um típico inteiro, o outro um número de de 32 bits, ou seja um típico inteiro longo.Neste exemplo mostramos como um inteiro de 2 bytes (16bits) é armazenado na memória em um formato Little Endian:#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;struct DWORD { uint8_t a0; uint8_t a1; } ;int main(void){ struct DWORD dw; dw.a0 = 0xDF; dw.a1 = 0xEA; printf(&quot;Endereço 0: %#X\\nEndereço 1: %#X\\n: %#X\\n&quot;, dw.a0, dw.a1); uint32_t dw1; memcpy(&amp;amp;dw1, &amp;amp;dw,4); //dw1 = 2; printf(&quot; Endereços 1 0\\n&quot;); printf(&quot;-------------------\\n&quot;); printf(&quot;Valor Word: %#hX\\n&quot;, dw1); return 0;Resultado para um WordA seguir um outro exemplo para um inteiro longo de 4 bytes (32 bits), apresentando como é armazenado na memória em um formato Little Endian. Observe as pequenas diferenças no código:#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;struct DWORD { uint8_t a0; uint8_t a1; uint8_t a2; uint8_t a3; } ;int main(void){ struct DWORD dw; dw.a0 = 0xDF; dw.a1 = 0xEA; dw.a2 = 0xAB; dw.a3 = 0xCF; printf(&quot;Endereço 0: %#X\\nEndereço 1: %#X\\nEndereço 2: %#X\\nEndereço 3: %#X\\n&quot;, dw.a0, dw.a1, dw.a2, dw.a3); uint32_t dw1; memcpy(&amp;amp;dw1, &amp;amp;dw,4); printf(&quot; Endereços 3 2 1 0\\n&quot;); printf(&quot;-------------------\\n&quot;); printf(&quot;Valor DWord: %#lX\\n&quot;, dw1); return 0;}Resultado para um DWordOutras formas de representaçãoHá outras formas de representação Endianess formas que misturam convenientemente os dois formatos acima, porém não entraremos em detalhes aqui como são apresentadas e utilizadas.Fontes https://en.wikipedia.org/wiki/Endianness https://en.wikipedia.org/wiki/Bit_numbering https://support.microsoft.com/pt-br/kb/102025 http://infocenter.arm.com/help/topic/com.arm.doc.dui0552a/I1835.html http://david.carybros.com/html/endian_faq.html https://www.ietf.org/rfc/ien/ien137.txt" }, { "title": "“Zicsr”, Control and Status Register (CSR) Instructions, Version 2.0", "url": "/posts/ziscr_-_control_and_status_register/", "categories": "extensoes, rv32i, zicsr", "tags": "rv32i, rv64i, rv128i, extensoes, 32bits, instrucoes, isa, zicsr, csr, control and status register, hart, timers, contadores, clock", "date": "2021-07-03 18:14:00 -0300", "snippet": "O RISC-V define um endereço separado de 4096 registradores de Status e Controle, associados com cada hart.CSRs são primáriamente utilizads pela arquitetura privilegiada, há vários usos no código não privilegiado incluindo para contadores e timers, e para status de ponto-flutuante.Os contadores e timers não são considerados obrigatórios no ISA base, e para instruções CSR necessárias para acessa-las estão tratadas separadamente na especificação no capítulo 2. Sendo assim, também tratarei as instruções especificas separamente." }, { "title": "Desenvolvendo um Sistema Operaconal para o RISCuinho passo a Passo", "url": "/posts/os_step-by-step/", "categories": "step-by-step", "tags": "step-by-step, os, operate system, bsd, linux, development, rv32m", "date": "2021-07-03 14:40:00 -0300", "snippet": "Neste artigo vou anotar meus estudos de como desenvolver um Sistema Operacional para o RISCuinho, como no momento somente temos a extensão RV32I funcionando não poderemos fazer quase nada, mas isso será motivação para desenvolver outras extensões conforme ouver demanda de instruções, assim irei desenvolver as demais extensões conforme a demanda deste sistema operacional.Este trabalho intercede e complementa outros trabalhos que tem a mesma caracteristicas, como o desenvolvimento da extensão RV32V que demanda as extensões RV32M, e o desenvolvimento do Chocopy que também demanda a extensão RV32M.Extensões que precisam ser desenvolvidasAlém do básico RV32I, há outras extensões que precisam ser desenvolvidas por completo ou parcialmente. Além de recursos de hardware que podem trazer grandes avanços quanto ao desempenho do RISCuinho, estas melhorias de hardware ainda não estão no meu foco principal, pois preciso me aprofundar melhor, principalmente, no desenvolvimento do pipeline, portanto de imediato já identifico que preciso finalizar a extensão RV32M, tabmém é provável que será necessário o desenvolvimento da extensão RV32A.Aos poucos, conforme estudo irei ampliando as anotações desta seção.O que preciso para começar.Vamos começar os estudos usando o QEMU, mas conforme o entendimento do desenvolvimento tomar corpo irei criar outro artigo usando o próprio RISCuinho simulado via iVerilog, ainda não sei como irei fazer para lidar com questões de comunicação externa, mas até lá, acredito que encontrarei soluções, use os comentários abaixo caso queira colaborar de alguma forma.Ferramentas para desenvolvimentoBem para desenvolver você vai precisar: GIT e ferramentas de apoio para baixar códigos de exemplo dos repositórios de desenvolvedores build-essential, que possui o GCC e outras ferramentas como binutils para compilação de código libfdt-dev e libsdl2-dev VI, o melhor editor para se trabalhar no Linux, também é bom para o Windows, mas no Windows eu prefiro o NotePad++sudo apt install build-essential git gitk vim libfdt-dev libsdl2-dev" }, { "title": "RISCuinho EABI", "url": "/posts/riscuinho_eabi/", "categories": "EABI", "tags": "assembly, c, cplusplus, abi, eabi, gcc", "date": "2021-07-01 08:40:00 -0300", "snippet": "A proposta para RISCuinho Embedded ABI (EABI) é um espelho da proposta RISC-V Embedded ABI (EABI) Version 20190525Será traduziada aos poucos.EABIThis is a proposal for a new ABI for RISC-V embedded systems. The newABI will be called the embedded ABI, aka EABI, and is intended forembedded targets only. It will not be used for Linux, which willcontinue to use the existing Unix ABI (UABI).NOTE: The UABI might provide higher performance or lower code size forsome embedded applications, and will continue to be available forembedded use.Contributors (please suggest corrections): Krste Asanovic, PalmerDabbelt, Bruce Hoult, Liviu Ionescu, Andrew Waterman, Jim WilsonGoals. The EABI is designed to reduce interrupt latency by reducing thenumber of caller-saved registers.. The EABI calling convention is designed to work the same on allRISC-V embedded targets with the same XLEN (i.e., for 32-bit systems,RV32I, RV32E, with or without the Zfinx option).. The EABI is designed to reduce library code size by reducing thesize of the largest floating-point data type from 128 bits to 64 bits.EABI OverviewThe EABI is based on the existing Unix ABI with the followingchanges:. The number of argument registers is reduced from 8 to 4.. The upper 16 x registers (x16-x31), where present, are allcallee-saved. (In UABI, 2 are argument registers and 4 aretemporaries.). The number of temporary registers is reduced from 3 to 2.. The long double type size will be reduced from 128-bits to64-bits.NOTE: Reducing the number of argument registers means 4 fewerregisters need to be saved in an interrupt handler, which gives fasterinterrupt response time.NOTE: Making the upper 16 registers all callee-saved means that we canuse the same calling convention for RV32I and RV32E. Also, it means 4fewer registers need to be saved in an interrupt handler, on top ofthe reduction from above.NOTE: Reducing the number of temporary registers means one lessregister to save in an interrupt handler.NOTE: Optimizing EABI for interrupt latency with fewer caller-saveregisters might have negative effects on performance and/or code sizerelative to UABI.NOTE: Reducing the size of long double helps reduce code size whenprintf is linked in. Currently, for a soft-float target, we need tolink in the 32-bit float, 64-bit double, and 128-bit long doublesoft-float libraries. With the change, we only need to link in thefirst two libraries. Similarly, on a hard-float target, we reducefrom one soft-float library to zero linked in with a printf call.Register Usage and Symbolic NamesThe RISC-V base ISA assumes x1 and x5 are used as link registersto hint any return address predictors in the machine, while the RISC-VC compressed extension effectively mandates x1 is the return addressregister and that x2 is the stack pointer.   EABI Name Description Saver x0 zero Hard-wired zero value - x1 ra Return address Caller x2 sp Stack pointer Callee x3 gp Global pointer - x4 tp Thread pointer - x5 t0 Temporary/link register Caller x6 s3 Saved register Callee x7 s4 Saved register Callee x8 s0/fp Saved register/frame pointer Callee x9 s1 Saved register Callee x10 a0 Argument/return value Caller x11 a1 Argument/return value Caller x12 a2 Argument Caller x13 a3 Argument Caller x14 s2 Saved register Callee x15 t1 Temporary Caller x16-x31 s5-s20 Saved registers Callee NOTE: If an entire embedded application and its libraries make no useof thread-local storage, the tp register becomes available as a globalregister or as a temporary register, at the application’s discretion.If the __global_pointer$ symbol is not defined, the gp registerbecomes available in the same fashion. Using the tp and gp registersin this alternate way is a nonstandard extension to the EABI and mightnot compose with some EABI libraries.EABI Stack AlignmentThe stack alignment for XLEN=32 systems is 8 bytes.NOTE: Stack alignment is not reduced below 8 bytes for RV32 systems incase of hardware support of double-precision floating-point (RV32D).The stack alignment for XLEN=64 systems is 16 bytes.NOTE: Maintaining stack alignment of 2*XLEN can help optimizedmicroarchitectures save/restore multiple registers per cycle.EABI Interrupt Handler Context SaveAn interrupt scheme wishing to provide a standard EABI interface forinterrupt handlers needs to save the following registers beforeentering an EABI interrupt handler:     ra x1 t0 x5 a0 x10 a1 x11 a2 x12 a3 x13 t1 x15 In addition, sp (x2) will need to be adjusted and might need to beswitched to a different interrupt stack; gp (x3) might need to beswitched to a different small-data section; and tp (x4) might needto be switched to a different thread-local storage region.Floating-Point Registers and Argument PassingFloating-point arguments are always passed in the integer registersa0-a3 or on the stack.Where the separate f floating-point registers are present, they aretreated as all callee-save, so there is no increase in interruptlatency. Systems with separate f registers will have to movefloating-point arguments to the floating-point registers to usehardware floating-point instructions, after first creating astack frame and storing some callee-saved floating-point registers.NOTE: A separate hard-float EABI could add a few caller-savedfloating-point argument and temporary registers to improve performanceand code size, but at the expense of supporting another incompatibleABI with increased interrupt latency.Systems implementing Zfinx have no additional f registers andprovide hardware floating-point instructions operating directly on thex registers.GCC ChangesThe gcc inline expanded memcpy will be changed to copy 4 registersat a time instead of 12, since we have eliminated 9 temporaryregisters.The gcc REG_ALLOC_ORDER macro is ABI-dependent. This can be fixedby defining the ADJUST_REG_ALLOC_ORDER macro to point at a functionthat then modifies the register allocation order depending on the ABI.Referẽncia https://github.com/riscv/riscv-eabi-spec/edit/master/EABI.adoc" }, { "title": "Riscuinho GCC", "url": "/posts/riscuinho-gcc/", "categories": "gcc", "tags": "gcc, binutils, as, gdb", "date": "2021-06-28 18:40:00 -0300", "snippet": "Gcc e Binutils para o RISCuinho foram compilados multi-lib para rv32i com ilp32; rv32im com ilp32 and rv32imc with ilp32 que reusará este conjunto multi-lib../configure –prefix=/opt/riscuinho –host=i686-riscuinho-linux-gnu –program-prefix=”riscuinho-“ –with-multilib-generator=”rv32ic-ilp32–m*v” –with-pkgversion=”RISCuinho-GCC” –with-bugurl=”https://riscuinho.github.io/gcc” –with-documentation-root-url=”https://riscuinho.github.io/gcc” –with-changes-root-url=”https://riscuinho.github.io/gcc” version: 11.1.0 multilib: . !march=rv32ic !march=rv32icv !march=rv32imc !march=rv32imcv !mabi=ilp32;rv32ic/ilp32 march=rv32ic !march=rv32icv !march=rv32imc !march=rv32imcv mabi=ilp32; *multilib_defaults: march=rv64imafdc mabi=lp64d *multilib_matches: march=rv32ic march=rv32ic;march=rv32icv march=rv32icv;march=rv32imc march=rv32imc;march=rv32imcv march=rv32imcv;mabi=ilp32 mabi=ilp32; IssuesCaso esteja tendo algum problemas com esta versão especifica do GCC, há duas opções, deixar detalhes do problemas no comentário abaixo, ou usar a versão oficial.Referências https://github.com/RISCuinho/riscv-gnu-toolchain https://gcc.gnu.org/install/configure.html" }, { "title": "Teste Chocopy", "url": "/posts/teste_chocopy/", "categories": "programação, chocopy", "tags": "exemplos, python, chocopy, assembly, venus", "date": "2021-06-27 20:00:01 -0300", "snippet": "Exemplo para teste.Problemas de compatibilidade com jekyll resolvidos (jekyll-plugin-search), porém agora há um problema quanto a carga do layout e estilo/css.# Search in a listdef contains(items:[int], x:int) -&amp;gt; bool: i:int = 0 while i &amp;lt; len(items): if items[i] == x: return True i = i + 1 return Falseif contains([4, 8, 15, 16, 23], 15): print(&quot;Item found!&quot;) # Prints thiselse: print(&quot;Item not found.&quot;)" }, { "title": "Exemplo Instruções Branch", "url": "/posts/Instrucoes_branch/", "categories": "exemplos", "tags": "assembly, codigos, exemplos, addi, bne, beq, meneumonico, b-type", "date": "2021-06-26 13:00:00 -0300", "snippet": "Instruções do tipo Branch no Assembly Risc-V, ou qualquer outro Assembly são usadas para construir algortimos similares a “If”O Exemplo abaixo foi criado abaixo foi criado pelo professor Fearghal Morgan da univeridade Nacional de Ireland em Galway e foi disponibilizada no curso de RISC-V no site https://vicilogic.com.bne rs2, rs1, imm Esta instrução faz uma ramificação relativa do código (quanto ao PC corrente), se rs2 não for igual a rs1.Decomposição da instrução bne x1, x0, decrAndBNELoop, veja que neste exemplo o endereço destino é representado por um label, assim ele é substituido pelo endereço relativo ao PC, o código para esta instrução gerado neste exemplo é: 0xfe009ee3 B-type imm(12¦10:5) rs2 rs1 funct3 imm(4:1¦11) opcode hex (0x):   0 0 0 1     6 3 bin (ob): (1 111 111) (0 0000) (0000 1) (001) (1110 1) (110 0011) No caso das instruções do tipo B (B-Type) a composição do valor Imediato (Imm) é um pouco mais complexa, como pode ver ele está espalhado pelo código da instrução, assim ele precisa ser montado, veja abaixo: 12 11 10:5 4:1 1 1 111 111 1110 O bit 0 do imediato é sempre o valor 0, já que não é preciso ser informado, o bit 2 não seria importante, porém temos a extensão compacta RV32C, neste caso o contador de endereço contabiliza a cada 2 bytes, mas quando RV32I e outras a contagem é feita a cada 4 bytes.imm(12:1) = 1 1 111 111 1110imm(0) = 0imm(12:0) = 1 1 111 111 1110 0 = 1 1111 1111 1100 = 0x1ffcextImm = 0xfffffffc# assembly program # Notes  (default imm format is decimal 0d)start:addi x1, x0, 3loop1: addi x1, x1, -1 bne x1, x0, loop1beq x0,x0, startDepois que você faz o assembly do programa acima no Venus, você obtem a seguinte listagem: PC Machine Code Basic Code Original Code 0x0 0x00300093 addi x1 x0 3 addi x1, x0, 3 0x4 0xFFF08093 addi x1 x1 -1 addi x1, x1, -1 0x8 0xFE009EE3 bne x1 x0 -4 bne x1, x0, loop1 0xc 0xFE000AE3 beq x0 x0 -12 beq x0,x0, start O Dump do mesmo assembly gera o seguinte programa binário com 4 instruções.00300093fff08093fe009ee3fe000ae3" }, { "title": "Extensões Padrão", "url": "/posts/extensoes_padrao/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, isa, 32bits, 64bits, 128bits", "date": "2021-06-26 10:00:00 -0300", "snippet": " Nome Descrição Versão Status Total de Instruções RV32I Base Integer Instruction Set - 32-bit 2.1 Frozen 49 RV32E Base Integer Instruction Set (embedded) - 32-bit, 16 registers 1.9 Open Same as RV32I RV64I Base Integer Instruction Set - 64-bit 2.0 Frozen 14 RV128I Base Integer Instruction Set - 128-bit 1.7 Open 14 M Standard Extension for Integer Multiplication and Division 2.0 Frozen 8 A Standard Extension for Atomic Instructions 2.0 Frozen 11 F Standard Extension for Single-Precision Floating-Point 2.0 Frozen 25 D Standard Extension for Double-Precision Floating-Point 2.0 Frozen 25 G Shorthand for the base and above extensions n/a n/a n/a Q Standard Extension for Quad-Precision Floating-Point 2.0 Frozen 27 L Standard Extension for Decimal Floating-Point 0.0 Open Undefined Yet C Standard Extension for Compressed Instructions 2.0 Frozen 36 B Standard Extension for Bit Manipulation 0.90 Open 42 J Standard Extension for Dynamically Translated Languages 0.0 Open Undefined Yet T Standard Extension for Transactional Memory 0.0 Open Undefined Yet P Standard Extension for Packed-SIMD Instructions 0.1 Open Undefined Yet V Standard Extension for Vector Operations 0.7 Open 186 N Standard Extension for User-Level Interrupts 1.1 Open 3 H Standard Extension for Hypervisor 0.0 Open 2 S Standard Extension for Supervisor-level Instructions 1.12 Open 7 Compondo multiplas extensõesAs extensões acima podem ser compostas formando processadores especializados ou de uso especificos direcionados. O processador mais generico é a RV32G que é composto pelas extensões IMFAD, se for 64 bits é RV64G e se for 128 bits é RV128G.As demais extensões devem ser referidas mantendo a mesma ordem que é listada na tabela acima, portando o correto é usar RV32GJVN, e não RV32JNVG." }, { "title": "Extensão padrão para operações com vetores", "url": "/posts/extensao_padrao_operacoes_com_vetores/", "categories": "extensoes, rv32v", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, rv32v, extensoes, vetores, isa, 32bits, 64bits, 128bits, machine learning, criptografia, vector machine", "date": "2021-06-26 10:00:00 -0300", "snippet": "No dia de escrita deste artigo, a extensão para operações com vetores tinha o release estável [v1.0-rc] (https://github.com/riscv/riscv-v-spec/releases/tag/v1.0-rc1). Este release é candidato a se tornar a versão v1.0 (frozen spec) para revisão pública.Versão/RevisãoO Projeto RISCuinho está trablando focado na revisão V1.0-rc1 que está aberta para revisão pública.Exemplo de codigo usando RV32V .text .balign 4 .global strcpy # char* strcpy(char *dst, const char* src)strcpy: mv a2, a0 # Copy dst li t0, -1 # Infinite AVLloop: vsetvli x0, t0, e8, m8, ta, ma # Max length vectors of bytes vle8ff.v v8, (a1) # Get src bytes csrr t1, vl # Get number of bytes fetched vmseq.vi v1, v8, 0 # Flag zero bytes vfirst.m a3, v1 # Zero found? add a1, a1, t1 # Bump pointer vmsif.m v0, v1 # Set mask up to and including zero byte. vse8.v v8, (a2), v0.t # Write out bytes add a2, a2, t1 # Bump pointer bltz a3, loop # Zero byte not found, so loop ret" }, { "title": "Single-Precision Floating-Point", "url": "/posts/extensao_padrao_single-precision_floating-point/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, isa, 32bits, 64bits, 128bits, single-precision, floating-point", "date": "2021-06-26 09:40:00 -0300", "snippet": "" }, { "title": "Standard Extension for Integer Multiplication and Division", "url": "/posts/extensao_padrao_multiplicacao_divisao_de_inteiros/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, 64bits, 128bits, inteiros, multiplicacao, divisao, isa", "date": "2021-06-26 09:40:00 -0300", "snippet": "" }, { "title": "Standard Extension for Atomic Instructions", "url": "/posts/extensao_padrao_instrucoes_atomicas/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, 64bits, 128bits, isa, atomic instructions", "date": "2021-06-26 09:40:00 -0300", "snippet": "" }, { "title": "Double-Precision Floating-Point", "url": "/posts/extensao_padrao_double-precision_floating-point/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, 64bits, 128bits, double-precision, floating-point", "date": "2021-06-26 09:40:00 -0300", "snippet": "" }, { "title": "Extensão de agregação", "url": "/posts/extensao_de_agregacao/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, 64bits, 128bits, isa", "date": "2021-06-26 09:40:00 -0300", "snippet": "A Extensão RV32G é defina apenas para ser uma apelido para um grupo especifico de extensão que compõem um processador funcional.A extensões que compõem o RV32G são: RV32M - Standard Extension for Integer Multiplication and Division RV32A - Standard Extension for Atomic Instructions RV32F - Standard Extension for Single-Precision Floating-Point RV32D - Standard Extension for Double-Precision Floating-Point" }, { "title": "Base Integer Instruction Set - 32-bit", "url": "/posts/base_integer_instruction_set_-_32bit/", "categories": "extensoes", "tags": "rv32i, rv64i, rv128i, rv32e, rv32m, rv32a, rv32f, rv32d, rv32g, rv32q, rv32c, rv32b, rv32j, rv32t, rv32p, rv32h, rv32s, rv32n, extensoes, 32bits, instrucoes, isa", "date": "2021-06-26 09:40:00 -0300", "snippet": "Conjunto de instruções base para RISC-V, abaixo listo as instruções que devem ser implementadas inicialmente numa implementação base RISC-V de 32 bits, as extensões 64 e 128, devem ter instruções extras com ajustes para as respectivas extensões." }, { "title": "Registradores Risc-V", "url": "/posts/registradores_no_risc-v/", "categories": "registradores", "tags": "assembly, registradores", "date": "2021-06-26 08:00:00 -0300", "snippet": "Um Risc-V possui 32 registradores que podem ser usados livremente, por são chamados de registradores de proposito geral, porém existe uma padronização atráves do ABI (Application Binary Interface) onde cada registrador recebe um nome e um uso, assim facilita uma maior integração no desenvolvimento de aplicações. Esta padronização facilita em muito o desenvolvimento em C.Registradores de Uso GeralNa Tabela abaixo apresento os registradores de uso geral e seu nome padrão, o nome ABI, e sua descrição Registrador Nome ABI Descrição Quem Grava x0 zero Fisicamente conectado a zero   x1 ra Endereço de Retorno Origem chamada x2 sp stack pointer Destino chamada x3 gp Ponteiro Global - x4 tp Ponteiro Thread - x5-7 t0-2 Registradores Temporários Origem Chamada x8 s0 / fp Registradore Preservado/Ponteiro de Frame Destino Chamada x9 s1 Resitrador Preservado Destino Chamada x10-11 a0-1 Argumentos de Função/Valores de Retorno Origem Chamada x12-17 a2-7 Argumentos de Função Origem Chamada x18-27 s2-11 Registradores Preservados Destino Chamada x28-31 t3-6 Registradores Temporarios Origem Chamada Registradores EspecificosNa extenção padrão RV32I além dos 32 registradores de proposito geral, há mais um registrador de uso especifico para uso do Programa Counter, ele é de uso interno e contem o valor do Program Counter, para ter acesso ao seu valor veja instruções AUIPC, JAL, JALR e detalhes nos artigos de exemplos.Registradores e ExtensõesAs extenções que alteram os comprimentos de bits do processador RISC-V de 32bits para 64 e 128, não alteram o número de registradores, apenas seu comprimento, portando o número de registradores neste tipo de extenção não alteara. Sendo assim os registradores sendo todos de 32bits, passam respectivamente a ser de 64 bits e 128 bits.No caso da extenção RV32E que é para Embarcados, o número de registradores é reduzido para 16, mas o comprimento dos mesmo é mantido em 32 bits.Algumas extensões podem adicionar novos registradores, não irei tratar aqui estes registradores, veja artigos relativos na tag registradores." }, { "title": "Configurando o GTKwave", "url": "/posts/configurando_gtkwave/", "categories": "gtkwave", "tags": "gtkwave, vcd, test, analise, verilog", "date": "2021-06-24 23:40:00 -0300", "snippet": "Projetar hardware nos tempos atuais demandam simulações, não partimos apenas de calculos e ideias, sem dúvida estes são os primeiros passos, mas durante a simulação precisamos ter métodos para analisar os sinais gerados e a ferramenta GTKWave é a melhor e mais consagrada para tal tarefa, é capaz de carregar diversos formatos de arquivos, sendo o formato VCD (Value Change Dump) o mais comum.Instalando o GTKWavepara instalar o GTKWave não há segredo, no linux basta usar o comando de instalação nativo de sua distribuição, no caso das variantes Debian que usam apt-get basta usar apt-get install gtkwave.Para Windows você pode fazer o donwload em https://sourceforge.net/projects/gtkwave/files/ e fazer o procedimento padrão de instalação.VCD (Value Change Dump)Não irei entrar em detalhes do formato VCD nesta publicação, quem sabe no futuro escrevo algo sobre o assunto, fique de olho no site na tag VCD, ou no forum do RISCuinho na página de exemplos.Um bom lugar para ler sobre este formato de arquivo, é no site ZipCPU, no artigo “Writing you own VCD file”.Usando o GTKWave com o RISCuinho.Após clonar o core do RISCuinho você pode usar o GTKWave para ver os sinais, para isso mude para o branch beta_0.x, digite o comando make normalmente ele irá executar um teste de simulação padrão da situação corrente do core, então ele criara um arquivo RISCuinho.vcd, você pode editar este arquivo para se familiar com seu conteúdo. Em seguida basta executar o comando make gtkwave, execute este comando apenas uma vez, ele irá abrir o gtkwave para você já configurado corretamente, você poderá alterar as configurações e sinais que deseja visulizar arrastando os sinais para a caixa da direita, depois você pode ir no menu: File &amp;gt; Write Save File ou pode usar a combinação [CTRL + S] assim irá salvar um arquivo de nome RISCuinho.gtkw na raiz do projeto, e quando chamar novamente o comando make gtkwave o gtkwave irá ser carregado novamente com as configurações salvas e o arquivo vcd do RISCuinho.Veja cada vez que chamar make gtkwave ele irá abrir uma nova instância do GTKwave.Conforme forem postando dúvidas no [Forum do RISCuinho]((https://github.com/RISCuinho/exemplos/discussions) ou nos [Issues]((https://github.com/RISCuinho/core/issues) amplio os artigos e tutoriais.Formatação de Tela do GTWaveO GTKwave foi formatado para grandes monitores, e pode ser um pouco desconfortável em telas pequenas, ao meu modo de ver considero qualquer tela menor que 21 olegadas uma tela pequena, portanto segue uma sugestão para melhorar a visualização dos sinais em monitores de 15 polegadas com baixa resolução.Abaixo apresento os parametros que uso em minha estação Linux de trabalho, como ela usa a resolução de 1028x800 em um monitor de 15.4” reduzir o tamanho da fonte para 8 pixels e optei pela fonte Monospace que me permite uma visualização mais estruturada dos valores.splash_disable onuse_nonprop_fonts 1use_big_fonts 0use_pango_fonts onfontname_signals Monospace 8fontname_waves Monospace 8fontname_logfile Screen 8editor &quot;subl3 %s&quot;enable_horiz_grid 0use_fat_lines 1" }, { "title": "Clonando o Core RISCuinho", "url": "/posts/Clonando_o_Core_Riscuinho/", "categories": "core", "tags": "core, clone, git, github, analise, verilog, hdl, desenvolvimento, colaborando", "date": "2021-06-24 23:40:00 -0300", "snippet": "Para obter uma cópia do projeto RISCuinho você deve começar pelo Core do processador, assim você deve clonar o repositore que se encontra no endereço https://github.com/RISCuinho/core, caso não tenha conhecimento do Git ou do GitHub sugiro começar pelo estudo do GIT no próprio site, não precisa dominar 100% a ferramenta, apenas os comandos básicos: clone pull diffConhecendo estes comandos, você já poderá se manter atualizado e ver as novidades sem ter que ficar visitando o site do GitHub, mas para contribuir com o projeto você precisa conhecer mais 3 comandos: push add commitClonando o projetoPara clonar o projeto basta vocẽ criar uma pasta de trabalho e nela digitar o seguinte comando:git clone https://github.com/RISCuinho/coreEste comando irá fazer o download de uma copia integral de todo o trabalho publicado no GitHub, apenas do código claro, as informações como issues, foruns, wiki e outros detalhes somente pelo site mesmo.Com este comando será criado uma pasta de nome core, esta pasta pode ter seu nome alterado, ou ao fazer o clone você pode informar um novo nome como abaixo:git clone https://github.com/RISCuinho/core riscuinho_coreAssim será criado uma pasta riscuinho_core que conterá o clone do repositório.Mantendo seu clone atualizado.Depois de clonar seu repositório, você pode mante-lo sempre atualizado, para isso basta sempre que quiser entrar na pasta “core” ou “riscuinho_core” ou o nome que escolheu usar, e digitar o comando:git pullLembre-se apartir de agora os demais comando devem ser digitado dentro da pasta criada que contem o clone de repositório.Referências Manual do Git Manuais do GitHub" }, { "title": "Forum de Exemplos", "url": "/posts/forum-exemplos/", "categories": "exemplos", "tags": "exemplos, fpga, tang nano, verilog, gowin, forum", "date": "2021-06-24 15:40:00 -0300", "snippet": "➡️ Para viabilizar o debate de exemplos estamos disponibilizandos o recurso de Discussão, assim podemos interconectar ideias e membros de nossa comunidade, esperamos com isso que você: Compartilhe Ideias; Apresente suas dúvidas; Se envolva com outros membros da comunidade; Convide outros a se tornarem membros e que sejam de mente aberta e com os mesmos ideias de compartilhar conhecimento e torna-lo mais democrático e acessível a todos sem distinção de classe, gênero, cor, raça e nacionalidade, valorizando a produção nacional por uma questão de patriotismo. 💪.📢 Para começar, faça um comentário abaixo se apresentando, falando de suas ideias 💡 e o que tem feito com o RISC-V e como pode colaborar com nosso projeto principalmente. Lembre-se de colocar os links 🔗 para seu perfil assim você divulga seu currículo caso isso seja importante." }, { "title": "Alem do Led Blink com a Tang Nano", "url": "/posts/Alem_do_Led_Blink_com_a_Tang_Nano/", "categories": "exemplos", "tags": "exemplos, fpga, tang nano, verilog, gowin", "date": "2021-06-20 18:40:00 -0300", "snippet": "Além do Led Blink com a TangNano, controlando um contador com um módulo de Som: https://www.twitch.tv/videos/1016278140TangNano: https://s.click.aliexpress.com/e/_99IQiPCabo USB Tipo C: https://s.click.aliexpress.com/e/_AkN3ALModulo de Sensores: https://s.click.aliexpress.com/e/_AeBgzRAs lives estão um pouco confusas pois a ferramenta picou a transmissão em várias, assim que puder irei melhorar e organizar, no momento estou sem computador adequado a este trabalho, então não dá para regravar os videos fazendo um tutorial mais resumido, ou edita-los de forma a focar no conteúdo.Portando abaixo vai os videos principais:" }, { "title": "Exemplo ADDi", "url": "/posts/ADDi/", "categories": "exemplos", "tags": "assembly, codigos, exemplos, addi, meneumonico, dump, i-type", "date": "2021-06-18 22:00:00 -0300", "snippet": "Abaixo apresento exemplo de uso da instrução ADDi, esta instrução faz a adição de um valor imediato (imm) a um registrador (rs1) e grava em outro ou no mesmo registrador (rd).addi rd, rs1, imm, rd = rs1 + immEstes exemplos foi obtido no tutorial: https://www.vicilogic.com/vicilearn/run_step/?s_id=1452exemplo addi x3, x3, 5decomposição da instrução `addi x3, x3, 5. I-type imm(11:0) rs1 f3 rd opcode hex (0x): [ 0 0 5 ] 0 3 0 0 3 1 3 bin (0b): [0000 0000 0101] [0 0011] [000] [0 0011] [001 0011] Ou seja:OpCode: 0x13SubFunção (f3): 0x00Valor Imediato: 0x005Registrador Origem: 0x03Registrador Destino: 0x03O OpCode e a funão identificam a operação que será realida no caso Soma de um valor Imediato (0x005) a um Registrador (X03).Exemplo de CódigoO código foi obtido no video tutorial da Vicilogic https://www.vicilogic.com/vicilearn/run_step/?s_id=1452Código Assembly:# assembly program # Notes (default imm format is decimal 0d)main:addi x3, x3, 5 # x3 = x3 + 5 addi x3, x3, 5 # x3 = x3 + 5 addi x3, x3, 5 # x3 = x3 + 5 O código abaixo foi obtido colando o assembly acima na ferramenta Venus PC instruction (31:0) basic assembly code original assembly code Notes 00 0x00518193 addi x3 x3 5 addi x3, x3, 5 # x3 = x3 + 5 04 0x00518193 addi x3 x3 5 addi x3, x3, 5 # x3 = x3 + 5 08 0x00518193 addi x3 x3 5 addi x3, x3, 5 # x3 = x3 + 5 ‘dump’ do programa em binario no simulador Venus. Número de Instruções = 3005181930051819300518193Referência https://riscuinho.github.io/venus/" }, { "title": "Usando o Python como ferramenta de apoio", "url": "/posts/usando_python/", "categories": "ferramentas", "tags": "ferramenta, python, python3, chocopy, debug, dump, vcd, venv", "date": "2021-06-18 18:40:00 -0300", "snippet": "O Python é usado no RISCuinho como ferramenta para ajudar nos testes, e também para ajudar a ensinar a programação assembler, mas neste post iremos falar da instalação de forma geral e em seguida com o foco para uso nos testes.Primeiro instale o Python3 e o pip3 em seu ambiente de trabalho como sugere os melhores artigos na internet, não irei entrar neste detalhe aqui pois há muitos artigos bons sobre isso e é uma tarefa muito simples.Em seguida crie um ambiente virtual para ele, onde irá instalar as bibliotecas especificas para uso no RISCuinho, por padrão convencionei que este ambiente virtual se chamará python_riscuin. Portanto basta digitar o comando abaixo na pasta “core” do projeto do RISCuinho. Você pode fazer isso também no Workspace onde trabalha nos projetos do RISCuinho se preferir.python3 -m venv python_riscuinAgora você deve ativar este ambiente para que os passos das seções a seguir sejam executados adequadamente e não interfiram na sua intalação Python de seus ambiente geral.. ./python_riscuin/activatecom este comando executado, sua linha de comando fica prefixada:(python_riscuin) ~/workspace/RISCuinho/core$ Instalando ferramentas para trabalhar com o VCDO VCD é um tipo de arquivo muito importante na depuração de projetos de design de hardware, ele é gerado pelas ferramentas de simulação Verilog, como o iVerilog e com o python podemos processa-los e analisar se tudo está correto como desejamos.Iremos usar em nossos testes o VCDVCD, para instala-lo é preciso também a biblioteca importlib_resources, use o comando a seguir:(python_riscuin) ~/workspace/RISCuinho/core$ pip install importlib_resources vcdvcdConsiderando que você já andou fazendo testes com o RISCuinho é bem certo que vocẽ tem um arquivo de extensão .vcd dentro da pasta core onde clonou o projeto de mesmo nome, se não tiver entre nesta pasta, se não estiver nela, e execute o comando make ele irá executar o iverilog e gerar um novo arquivo RISCuin.vcd.Agora para testar se tudo está ok, basta digitar o comando:(python_riscuin) ~/workspace/RISCuinho/core$ vcdcat RISCuin.vcd |lessVeja nesta primeira interação usei o less, para facilitar, pois o riscuinho nesta versão tem mais de 170 sinais disponivéis (gerando linhas com 800 colunas), além de ter pelo menos 300 linhas só no exemplo com 3 instruções addi, então escolhi alguns sinais e vou apresenta-los de uma forma diferentte, com o comando a seguir apenas quando eles se alteram:(python_riscuin) ~/workspace/RISCuinho/core$ vcdcat -x RISCuin.vcd time RISCuin_tb.finish_rst RISCuin_tb.start_rst RISCuin_tb.rst RISCuin_tb.pc_end RISCuin_tb.cpu.pc_enable -do comando acima lista expecificamente os sinais indicados -x e apenas os apresenta quando váriam de valor -d (delta), experimente o comando sem o delta.Mais tarde trago mais informações sobre o uso do VCDVCD." }, { "title": "Global Offset Table", "url": "/posts/global_offset_table/", "categories": "assembly", "tags": "assembly, got, pic, pie", "date": "2021-06-18 18:40:00 -0300", "snippet": "A “Global Offset Table”, ou GOT, é uma seção da memória do programa (executável ou biblioteca compartilhada) usada para abilitar o programa compilado como ELF para que seja executado corretamente, independente do endereço de memória que o programa ou dado foi carregado no runtime.Seu mapa de símbolos no código de programa, corresponde ao endereço absoluto de memória para facilitar o Position Independent Code (PIC) e Position Independent Executables (PIE) que são carregados para diferentes endereços de memória cada vez que o programa é iniciado. O endereço de runtime de memória, também conhecido como endereço absoluto de memória de variaves e funções é conhecido antes do programa ser inciado quando PIC ou PIE do codigo é executado para não ser hardcoded durante a compilação pelo compilador.O Global Offset Table é representado pelas seções .got e .got.plt nos arquivos “ELF” que são carregados na memória de programa na inicialização. O dynamic linker do sistema operacinal é usado para atualizar a realocação do “global offset table” (simbolos para endereços de memória absoluta) quando o programa é inicializado ou os simbolos são acessados. É um mecanismo que permite bibliotecas compartilhadas (.so) ser realocadas para diferntes endereços de memória no inicio do programa evitar conflitos de endreços do programa principal ou outras bibliotecas compartilhadas, e evitar técnicas de invasão como “exploits”." }, { "title": "Inaugurando Novo Site", "url": "/posts/Inaugurando_Novo_Site/", "categories": "site", "tags": "site", "date": "2021-06-18 18:40:00 -0300", "snippet": "RISCuinho - A scratch in the possibilities in the universe of microcontrollersRISCuinho (Risquinho), in portuguese is a small scratch on the surface of something, and this represents the proposal of this project that starts in a very didactic way, doing the minimum necessary by scratching the surface of what can be done with a Core or multiple RISC Cores.This project is educational and aims at my study on microprocessors and to teach my introductory courses on microprocessor programming and architecture at Arduino Minas (Curso Maker/Geringonça Maker Space). RISCuinho (Risquinho) will also be used for my RTOS studies when it is possible to multiply its core to simulate multicore microcontrollers.I am a autodidata student I do not have a computer science course and no course that gives me the basis to create such a microcontroller, however I am graduated in Computer Network Design and Implementation, I have some programming courses, Project Management and other related areas, I used to create it was through studies of specialized books such as those discussed in the bibliography section and on websites on the internet.All this material was assimilated with the help of conversations in the RISC-V Brasil group on Telegram, where participants from different areas related to IT and exchange experience on microprocessors and microcontrollers, some renowned professionals in the sector, which I am very grateful in the sector, in particular: Marcelo Samsoniuk (@samsoniuk) Core Risc DarkRiscv Paulo Matias (@thotypous) Lucas Teske (@racerxdl) Core RISC RISCow Marcus Medereiros (@zxmarcos) Core RISC Riscado-V Jecel JrI will use Portuguese as the official language of this project, but English can also be used for requests for information and suggestions.Eu usarei o português como idioma oficial deste projeto, porém o inglês também pode ser usado para solicitações de informações e sugestões.Arquitetura do MicrocontroladorO RISCuinho (Risquinho) usa aa Arquitetura Havard simples, com a memória de programa espelhada no endereço de memória de dados, para que possa ser reprogramada a aquente e demonstrar recursos modernos de microcontroladores que possuem tal recurso, isso será discutido futuramente em documentação apropriada.O RISCuinho possui 32 registradores conforme a especificação RV32I. Possui todas as intruções básicas para operação com numeros inteiros implementadas. Ele não possui instruções de Sistema, Sincronismo e Controle implementadas nesta versão.O RISCuinho também é um core de um 3 estágio de um único ciclo de clock, em versões futuras será desenvolvido um pipeline mais complexo.ExemplosA pasta examples, no projeto core do RISCuinho, descrita aqui na categoria “exemplos”, possui exemplos para testes, na sua maioria obtidos no curso oferecido pela [Vicilogic][https://www.vicilogic.com/], tais exemplos podem ser obtidos no link https://www.vicilogic.com/vicilearn/run_step/?s_id=1452, para detalhes de cada exemplo que foi usado pra teste, entre no anterior.SimulaçãoAs Simulações estão sendo feitas com IVerilog no Windows 10 com WSL, a condificação é feita no VSCode, e a verificação dos sinais gerados com GTKWave.As instruções são testadas tanto no ambiente Vicilogic como no simulador emulsiVSintese e HardwareEstou escolhendo algumas ferramentas mais populares e consagradas para sintetizar o RISCuinho e coloca-lo funcionando em um FPGA físico, abaixo listo algumas informações sobre isso.GoWinGoWin é uma empresa de semicondutores chinesa que produz uma linha facinante de FPGA com uma abordagem bastante intrigante que tem causando bastante embaraço na comunidade, já que com sua abordagem consegue reduzir drásticamente o uso de LUTs, pois vem dotado de um grande número de recursos como ALUs e registradores.Ainda estou me familiarizando com ela, mas já descobrindo que pode ser uma grande aliada para o RISCuinho.TangNanoTangNano é uma placa de prototipação que vem empoderada com um FPGA GW1N-LV1QN48C6/I5, equipado com 1152 LUT4, 1 PLL e um total de 72Kbit SRAM em 4 Block, enpacotado numa QFN48.A TangNano disponibiliza todas as portas de forma bem acessível.Também vem com uma PSRAM de 64MBits e possui um conector para LCD RGB e a pinagem para uso com VGA, já vem conectada a um LED RGB também. Além de um cristal de 24Mhz, porta USB Type-C e JTAG.QuartusEstou usando o Quartus 20.4 Prime Lite Edtion para fazer os testes em uma placa De0-nano.De0-NanoPlaca de prototipação e estudos da Terasic.Estou usando a De0-nano versão 1.6: FPGA: Altera Cyclone IV EP4CE22FE22F17C6N" } ]
